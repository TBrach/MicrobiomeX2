apply(mat, 1, function(taxon_ratios){
x <- taxon_ratios[group_fac == i]
x <- x[is.finite(x) & x != 0] # removes all ratios in which one of the two taxa was not present!
y <- taxon_ratios[group_fac == j]
y <- y[is.finite(y) & y != 0] # removes 0/0 = NaN, 0/x = 0, x/0 = Inf
if (test == "wilcoxon"){
if (length(x) > 0 && length(y) > 0){
pValue <- wilcox.test(x = x, y = y, alternative = "two", paired = F, exact = F)$p.value
# NB: wilcox.test ignores in default setting (maybe see na.action) NA, NaN, Inf, -Inf
# For plot: change sign of pValue to negative if taxon is more abundant in group 1.
Ranks <- rank(c(x[!is.na(x)], y[!is.na(y)]))
n1 <- length(x[!is.na(x)])
n2 <- length(y[!is.na(y)])
Wx <- sum(Ranks[1:n1])-(n1*(n1+1)/2)
Wy <- sum(Ranks[(n1+1):(n1+n2)])-(n2*(n2+1)/2)
if(Wx > Wy){pValue <- -1*pValue}
pValue
} else {
pValue = 1
}
} else if (test == "t.test") {
if (length(x) > 1 && length(y) > 1 && var(x) > 0 && var(y) > 0){
pValue <- t.test(x = x, y = y, alternative = "two")$p.value
if (mean(x, na.rm = T) > mean(y, na.rm = T)){pValue <- -1*pValue}
pValue
} else {
pValue <- 1
}
}
})
})
# make sure diagonal is all NA (can be exceptions especially for t.test)
diag(pValMatrix) <- NA
# - adjust p-values if asked for -
signs <- pValMatrix < 0
signs[is.na(signs)] <- FALSE
pValMatrix <- abs(pValMatrix)
for (e in 1:nrow(pValMatrix)){
pValMatrix[e, ] <- p.adjust(pValMatrix[e, ], method = p_adjust_method)
} # equal to t(apply(pValMatrix, 1, p.adjust, method = p_adjust))
pValMatrix[signs] <- pValMatrix[signs]*(-1)
DF <- as.data.frame(pValMatrix)
DF[is.na(DF)] <- 2 # just to avoid missing values in plot and have a clear non-pValue value to mark self comparisons as black
DF$HostTaxon <- rownames(pValMatrix)
rm(group_fac_current)
DF <- tidyr::gather(DF, key = Taxon , value = pValue, - HostTaxon)
if (is.null(tax_order)) {
DF$Taxon <- factor(DF$Taxon, levels = rownames(pValMatrix), ordered = TRUE)
DF$HostTaxon <- factor(DF$HostTaxon, levels = rev(rownames(pValMatrix)), ordered = TRUE)
} else {
if(!all(rownames(pValMatrix) %in% tax_order)){
stop("given tax_order does not fit to tax_names")
}
DF$Taxon <- factor(DF$Taxon, levels = tax_order, ordered = TRUE)
DF$HostTaxon <- factor(DF$HostTaxon, levels = rev(tax_order), ordered = TRUE)
}
fill_colors <- c(color_levels, ns = "gray98", " " = "black")
DF$Fill <- "ns"
DF$Fill[DF$pValue < signi_level & DF$pValue > 0] <- i
DF$Fill[DF$pValue > -1*signi_level & DF$pValue < 0] <- j
DF$Fill[DF$pValue == 2] <- " "
DF$Fill <- factor(DF$Fill, levels = names(fill_colors), ordered = T)
TileTr <- ggplot(DF, aes(x = Taxon, y = HostTaxon, fill = Fill))
TileTr <- TileTr +
geom_raster() +
# ggtitle(paste(i, " vs ", j, sep = "")) +
scale_fill_manual("", values = fill_colors) +
scale_x_discrete(position = "top") +
labs(x=NULL, y=NULL) +
theme_bw() +
#theme_tufte(base_family="Helvetica") +
theme(panel.border = element_blank(),
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0),
axis.ticks=element_blank())
TileTr
create_raw_TbT_TilePlot <- function(TbTmatrixes, physeq, group_var, color_levels, tax_names = NULL, tax_order = NULL,
test = "wilcoxon", signi_level = 0.05, p_adjust_method = "none") {
if(!identical(length(TbTmatrixes), ntaxa(physeq))){stop("TbTmatrixes don't fit to physeq")}
if(ncol(TbTmatrixes[[1]]) != nsamples(physeq)){stop("TbTmatrixes don't fit to physeq. Not the same number of samples.")}
if(test != "wilcoxon" & test != "t.test"){stop("test unknown, must be wilcoxon or t.test")}
if(! group_var %in% colnames(sample_data(physeq))) {
stop("The given group_var is not a variable in the sample data of the loaded phyloseq object.")
}
group_fac <- factor(sample_data(physeq)[[group_var]])
compare <- names(color_levels)
if (!is.null(compare)) {
group_var_levels <- compare
} else {
group_var_levels <- levels(group_fac)
}
if (length(group_var_levels) != 2) {
stop(paste0("compare (names(color_levels)) must consist of two groups - you asked for ",
paste(group_var_levels, collapse = ", ")))
}
if (!all(group_var_levels %in% levels(group_fac))) {
stop("Not all given compare (group_var_levels) are actually levels in group_var column.")
}
# - check that given tax_names fit to physeq and change taxa_names of physeq -
if (is.null(tax_names)){
tax_names <- paste("T", 1:ntaxa(physeq), sep = "_")
}
if(!identical(ntaxa(physeq), length(tax_names))){stop("tax_names do not fit in length to physeq")}
tax_names <- make.unique(tax_names)
# --
names(TbTmatrixes) <- tax_names
TbTmatrixes <- lapply(TbTmatrixes, function(mat){
rownames(mat) <- tax_names
mat
})
i <- group_var_levels[1]
j <- group_var_levels[2]
# ntaxa * ntaxa wilcoxon tests take time if you have a lot of taxa!
pValMatrix <- sapply(TbTmatrixes, function(mat){
apply(mat, 1, function(taxon_ratios){
x <- taxon_ratios[group_fac == i]
x <- x[is.finite(x) & x != 0] # removes all ratios in which one of the two taxa was not present!
y <- taxon_ratios[group_fac == j]
y <- y[is.finite(y) & y != 0] # removes 0/0 = NaN, 0/x = 0, x/0 = Inf
if (test == "wilcoxon"){
if (length(x) > 0 && length(y) > 0){
pValue <- wilcox.test(x = x, y = y, alternative = "two", paired = F, exact = F)$p.value
# NB: wilcox.test ignores in default setting (maybe see na.action) NA, NaN, Inf, -Inf
# For plot: change sign of pValue to negative if taxon is more abundant in group 1.
Ranks <- rank(c(x[!is.na(x)], y[!is.na(y)]))
n1 <- length(x[!is.na(x)])
n2 <- length(y[!is.na(y)])
Wx <- sum(Ranks[1:n1])-(n1*(n1+1)/2)
Wy <- sum(Ranks[(n1+1):(n1+n2)])-(n2*(n2+1)/2)
if(Wx > Wy){pValue <- -1*pValue}
pValue
} else {
pValue = 1
}
} else if (test == "t.test") {
if (length(x) > 1 && length(y) > 1 && var(x) > 0 && var(y) > 0){
pValue <- t.test(x = x, y = y, alternative = "two")$p.value
if (mean(x, na.rm = T) > mean(y, na.rm = T)){pValue <- -1*pValue}
pValue
} else {
pValue <- 1
}
}
})
})
# make sure diagonal is all NA (can be exceptions especially for t.test)
diag(pValMatrix) <- NA
# - adjust p-values if asked for -
signs <- pValMatrix < 0
signs[is.na(signs)] <- FALSE
pValMatrix <- abs(pValMatrix)
for (e in 1:nrow(pValMatrix)){
pValMatrix[e, ] <- p.adjust(pValMatrix[e, ], method = p_adjust_method)
} # equal to t(apply(pValMatrix, 1, p.adjust, method = p_adjust))
pValMatrix[signs] <- pValMatrix[signs]*(-1)
# --
# -- add a tile plot of the pValMatrix --
DF <- as.data.frame(pValMatrix)
DF[is.na(DF)] <- 2 # just to avoid missing values in plot and have a clear non-pValue value to mark self comparisons as black
DF$HostTaxon <- rownames(pValMatrix)
DF <- tidyr::gather(DF, key = Taxon , value = pValue, - HostTaxon)
if (is.null(tax_order)) {
DF$Taxon <- factor(DF$Taxon, levels = rownames(pValMatrix), ordered = TRUE)
DF$HostTaxon <- factor(DF$HostTaxon, levels = rev(rownames(pValMatrix)), ordered = TRUE)
} else {
if(!all(rownames(pValMatrix) %in% tax_order)){
stop("given tax_order does not fit to tax_names")
}
DF$Taxon <- factor(DF$Taxon, levels = tax_order, ordered = TRUE)
DF$HostTaxon <- factor(DF$HostTaxon, levels = rev(tax_order), ordered = TRUE)
}
fill_colors <- c(color_levels, ns = "gray98", " " = "black")
DF$Fill <- "ns"
DF$Fill[DF$pValue < signi_level & DF$pValue > 0] <- i
DF$Fill[DF$pValue > -1*signi_level & DF$pValue < 0] <- j
DF$Fill[DF$pValue == 2] <- " "
DF$Fill <- factor(DF$Fill, levels = names(fill_colors), ordered = T)
TileTr <- ggplot(DF, aes(x = Taxon, y = HostTaxon, fill = Fill))
TileTr <- TileTr +
geom_raster() +
# ggtitle(paste(i, " vs ", j, sep = "")) +
scale_fill_manual("", values = fill_colors) +
scale_x_discrete(position = "top") +
labs(x=NULL, y=NULL) +
theme_bw() +
#theme_tufte(base_family="Helvetica") +
theme(panel.border = element_blank(),
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0),
axis.ticks=element_blank())
TileTr
}
TbT_tile <- create_raw_TbT_TilePlot(TbTmatrixes = raw_TbTmatrixes, physeq = physeq_to_test, group_var = group_var, color_levels = color_levels, signi_level = 0.05, tax_names = taxa_annotation, tax_order = names(phylum_colors), test = "wilcoxon", p_adjust_method = "none")
TbT_tile
rm(list = ls())
# - source all functions -
functionpath <- "./Functions"
source(file.path(functionpath, "_n_000_helper_functions.R"))
source(file.path(functionpath, "_n_010_explore_ps_functions.R"))
source(file.path(functionpath, "_n_020_alpha_diversity_functions.R"))
source(file.path(functionpath, "_n_030_preprocess_filtering_functions.R"))
source(file.path(functionpath, "_n_040_beta_diversity_functions.R"))
source(file.path(functionpath, "_n_050_diff_abundance_functions.R"))
source(file.path(functionpath, "_n_060_phylum_analysis_functions.R"))
# --
# - load your phyloseq object -
# NB: USER INPUT
# name_phyloseq_rds <- "physeq_Men.rds"
name_phyloseq_rds <- "physeq_Men_Hol.rds"
# NB: USER INPUT
datapath <- "./Example_phyloseq_objects"
# Test your input:
if(! file.exists(file.path(datapath, name_phyloseq_rds))){
stop("The given path/file to your phyloseq object does not exist.")
}
ps <- readRDS(file.path(datapath, name_phyloseq_rds))
# --
# - Define the group variable for sample comparisons -
# NB: USER INPUT
group_var <- "Country" # MANDATORY: a variable in sample_data(ps) based on which samples will be compared
# Test your input:
if(! group_var %in% colnames(sample_data(ps))) {
stop("The given group_var is not a variable in the sample data of the loaded phyloseq object.")
}
# --
# - Define the two levels in your group_var that you want to compare -
# NB: USER INPUT
group_var_levels <- c("IN", "DK") # defines the order of the groups in all plots. If set to NULL:
if (is.null(group_var_levels)) {
group_var_levels <- unique(sample_data(ps)[[group_var]])
}
# Test your input:
if (!all(group_var_levels %in% unique(sample_data(ps)[[group_var]]))) {
stop("Not all given group_var_levels are actually levels in group_var column.")
}
if (length(group_var_levels) != 2) {
stop("Sorry, for MicrobiomeX2 group_var_levels needs to consist of exactly 2 levels.")
}
# make sure sample_data(ps) is a factor (not totally necessary but in case there is no ordering in one of the functions)
sample_data(ps)[[group_var]] <- factor(sample_data(ps)[[group_var]], levels = c(group_var_levels, setdiff(unique(sample_data(ps)[[group_var]]), group_var_levels)), ordered = TRUE)
# --
# - Set the colors representing the groups in your group_var_levels -
# NB: so also color_levels must consist of exactly two colors
# NB: USER INPUT
color_levels <- c(cbPalette[2], cbPalette[4]) # choose your preferred colors for each group in your group_var. If set to NULL:
if (is.null(color_levels)) {
color_levels <- c(cbPalette[2], cbPalette[4])
}
# Test your input:
if (length(color_levels) != length(group_var_levels)) {
stop("The number of colors in the given color_levels did not fit to group_var_levels.")
}
if (!all(areColors(color_levels))) {
stop("Stopped because not all entries in color_levels were valid R colors.")
}
names(color_levels) <- group_var_levels
# --
# - optional: use another variable in sample_data(ps) as shape in some of the plots -
# NB: user input
shape <- "Gender"
# Test your input:
if (!is.null(shape)) {
if (! shape %in% colnames(sample_data(ps))) {
stop("The given shape is not a variable in the sample data of the loaded phyloseq object.")
}
}
# --
# - Set the taxonomic_level for the analysis -
# NB: You can choose all levels within colnames(tax_table(ps))
# phyloseq::taxglom will be used to adjust the phyloseq object to the chosen taxonomic_level.
# if you set taxonomic_level to NULL, all taxa will be analysed (i.e. strain/species/ASV level analysis)
# NB user input
taxonomic_level <- "Species"
# NB user input
phylum_NA_removal <- "no" # if yes you remove all taxa for which Phylum = NA before the analyses
# Test your input:
if (!is.null(taxonomic_level) && !(taxonomic_level %in% colnames(tax_table(ps)))){
stop("You provided a taxonomic_level that is not present in the tax_table of the loaded phyloseq object.")
}
# --
# - Filtering inputs -
# NB: user input
prevalence <- 0 # in percent, for prevalence filtering of taxa
# NB: user input
min_obs <- 0L # in counts, a taxon will be considered present (for prevalence) if count > min_obs
# NB: user input
taxa_sums_quantile <- 100 # in percent, taxa whose taxa_sums are above this threshold will be kept even if they do not pass prevalence filter
# Test filtering inputs and set invalid inputs to defaults
if (!is.numeric(prevalence) || prevalence < 0 || prevalence > 100) {
prevalence <- 0
}
if (!is.numeric(min_obs)) {
min_obs <- 0L
}
if (!is.numeric(taxa_sums_quantile) || taxa_sums_quantile < 0 || taxa_sums_quantile > 100) {
taxa_sums_quantile <- 100
}
# --
# - Alpha diversity and rarifaction inputs -
# NB: user input
alpha_div_measures <- c("Observed", "Shannon") # ?phyloseq::estimate_richness: may include c("Observed", "Chao1", "ACE", "Shannon", "Simpson", "InvSimpson", "Fisher")
# NB: user input
seed <- 1234 # for reproducibility of rarefaction curves
# NB: user input
step_size <- 200 # steps in sample_sums for rarefaction curves
# NB: user input
rare_level <- NULL # sample_sums/total_counts level to which rarefaction is perforemd, if NULL, min(sample_sums(ps)) is used!
# NB: user input
rare_max_total <- NULL # maximal sample_sums/total_counts value to which rarefaction curves are calculated, if NULL: quantile(sample_sums(ps), probs = .25) is used
# Test alpha-diversity inputs and set invalid inputs to defaults
if (! all(alpha_div_measures %in% c("Observed", "Chao1", "ACE", "Shannon", "Simpson", "InvSimpson", "Fisher"))) {
alpha_div_measures <- c("Observed", "Shannon")
}
if (!is.numeric(seed)) {
seed <- 1234
}
if (!is.numeric(step_size)) {
step_size <- 200
}
if (!is.numeric(rare_level)) {
rare_level <- NULL # will be changed to min(sample_sums(ps))
}
if (!is.numeric(rare_max_total)) {
rare_max_total <- NULL # quantile(sample_sums(ps), probs = .25)
}
# --
# - beta diversity inputs -
dist_methods <- c("bray") # otions: see unlist(phyloseq::distanceMethodList)
coord_cor <- FALSE # adjustment of the axis representation in ordination plots
# Test beta diversity inputs and set invalid inputs to defaults
if (! all(dist_methods %in% unlist(phyloseq::distanceMethodList))) {
dist_methods <- c("bray")
}
if (! is.logical(coord_cor)){
coord_cor <- FALSE
}
# --
# - remove taxa with Phylum == NA -
ps <- phyloseq::subset_taxa(ps, taxa_sums(ps) != 0)
# --
taxa_before <- ntaxa(ps)
# - remove taxa with Phylum == NA -
if (phylum_NA_removal == "yes"){
ps <- phyloseq::subset_taxa(ps, !is.na(Phylum))
}
# --
# - caluclation of Size Factors -
SFs <- calc_SFs(physeq = ps)
# --
# - perform tax_glom -
if (!is.null(taxonomic_level)){
ps <- phyloseq::tax_glom(ps, taxrank = taxonomic_level, NArm = FALSE)
} else {
taxonomic_level <- "Species" # for later labelling in plots, even though in this case it is ASV level analysis but there is no strain taxonomy in taxa_table
}
# --
# - generate library_size adjusted ps object -
library_size_adjust_list <- simply_adjust_LS(ps, SFs = SFs)
ps_tca <- library_size_adjust_list[[1]]
# --
Phyla <- check_phyla_distribution(ps_tca)
knitr::kable(Phyla, caption = "Phyla Distribution")
# - Define here phylum colors for later plots based on the phyla distribution
phylum_colors <- make_color_vector(as.character(Phyla$Phylum), QuantColors15)
# - filtering  -
# NB: SFs were already calculated in exploratory analysis
ps_tca_filt <- phyloseq::filter_taxa(ps_tca, function(x){
(sum(x > min_obs) > (prevalence/100)*length(x)) ||
(sum(x) > quantile(taxa_sums(ps_tca), probs = taxa_sums_quantile/100))
}, prune = TRUE)
ps_filt <- phyloseq::prune_taxa(taxa_names(ps_tca_filt), ps) # you need ps_filt for DESeq2Apply_physeq
ps_filt_ra <- phyloseq::transform_sample_counts(ps_filt, function(x){x/sum(x)})
# --
# - Generate a visual overview of the filtering step -
filterList <- visualize_filtering(physeq = ps_tca, prevalence = prevalence, taxa_sums_quantile = taxa_sums_quantile)
# --
physeq_to_test <- ps_filt_ra
# - calculate the beta diversity distances -
dist_list <- calc_beta_div_distances(physeq_to_test, dist_methods, group_var = group_var, compare = group_var_levels) # produces objects of class "dist"
# - gemerate boxplots comparing within to between group distances and test significance by t.test-
# NB: takes time if there are many samples, so you might want to take it out if there are many
dist_analysis_list <- compare_beta_div_distances_directly_new(dist_list = dist_list, physeq = physeq_to_test, group_var = group_var, color_levels = color_levels, jitter_up_to = 100, test = "t.test", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")),
p.adjust.method = "BH", hide.ns = FALSE)
# - choose the physeq object to run the test on -
physeq_to_test <- ps_filt
# - run the test function resulting in result list - NB: a bit special for DESeq because you also get a new physeq
res_list <- test_differential_abundance_DESeq2single(physeq = physeq_to_test, group_var = group_var, compare = group_var_levels, SFs = SFs, p.adjust.method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")), cooksCutoff = FALSE)
length(res_list)
names(res_list)
diff_ab_df <- res_list[[1]]
physeq_to_test <- res_list[[2]]
View(diff_ab_df)
# - catch the hits -
hit_list <- format_hit_table(diff_ab_df, p.adjust.threshold = 0.05, p.adjust.method = NULL)
taxa_hit_df <- hit_list[["hit_table"]]
# - define colors for heatmap -
significance_colors <- brewer.pal(4, "Reds")
significance_colors <- c(rev(significance_colors), "gray", "violet")
names(significance_colors) = c("****", "***", "**", "*", "ns", "?")
taxa_colors <- list("signi_adj" = significance_colors, "Phylum" = phylum_colors)
if (!is.null(shape)){
sample_colors <- list(color_levels, NA)
names(sample_colors) <- c(group_var, shape)
} else {
sample_colors <- list(color_levels)
names(sample_colors) <- group_var
}
# - get a more informative taxa annotation of the hits -
taxa_annotation <- get_taxon_names(taxa_hit_df)
taxa_annotation1 <- paste(taxa_annotation, " (", taxa_hit_df$signi_adj, ")", sep = "")
# - prepare violin plots -
taxa_illustrated <- 10
head(taxa_hit_df, taxa_illustrated)
physeq = physeq_to_test
group_var = group_var
color_levels = color_levels
taxa_info_df = head(taxa_hit_df, taxa_illustrated)
taxa_annotation = head(taxa_annotation1, taxa_illustrated)
taxa_illustrated
facet_cols = 5
violin_plots <- plot_hittaxa_boxAndviolin(physeq = physeq_to_test, group_var = group_var, color_levels = color_levels, taxa_info_df = head(taxa_hit_df, taxa_illustrated), taxa_annotation = head(taxa_annotation1, taxa_illustrated), shape = shape, facet_cols = 5, excludeZero = FALSE, logTransform = FALSE)
violin_plots[[2]]
facet_cols = 5
excludeZero = FALSE
logTransform = FALSE
violin_plots <- plot_hittaxa_boxAndviolin(physeq = physeq_to_test, group_var = group_var, color_levels = color_levels, taxa_info_df = head(taxa_hit_df, taxa_illustrated), taxa_annotation = head(taxa_annotation1, taxa_illustrated), shape = shape, facet_cols = 5, excludeZero = TRUE, logTransform = FALSE)
violin_plots[[2]]
excludeZero = FALSE
physeq_to_test <- ps_filt_ra
ps_filt_ra
group_var
compare
compare = group_var_levels
physeq
keepSamples <- sample_names(physeq)[sample_data(physeq)[[group_var]] %in% compare]
physeq <- prune_samples(keepSamples, physeq)
physeq
taxa_sums(physeq)
min(taxa_sums(physeq))
group_var
compare
compare <- c("IN", "HOL")
physeq_to_test <- ps_filt_ra
keepSamples <- sample_names(physeq)[sample_data(physeq)[[group_var]] %in% compare]
physeq <- prune_samples(keepSamples, physeq)
physeq
min(taxa_sums(physeq))
physeq_to_test <- ps_filt_ra
dist_methods
compare1 <- compare
compare1
# - calculate the beta diversity distances -
dist_list <- calc_beta_div_distances(physeq_to_test, dist_methods, group_var = group_var, compare = group_var_levels) # produces objects of class "dist"
brayAll <- dist_list[[1]]
brayAll
calc_beta_div_distances <- function(physeq, dist_methods = c("bray"), group_var = NULL, compare = NULL) {
if (!is.null(group_var) || !is.null(compare)){
if(! group_var %in% colnames(sample_data(physeq))) {
stop("The given group_var is not a variable in the sample data of the phyloseq object.")
}
if (!all(compare %in% unique(sample_data(physeq)[[group_var]]))) {
stop("Not all names in compare are actually levels in the group_var column.")
}
keepSamples <- sample_names(physeq)[sample_data(physeq)[[group_var]] %in% compare]
physeq <- prune_samples(keepSamples, physeq)
# not sure if taxa that are not present in a single sample after the prune affect distance?:
physeq <- phyloseq::subset_taxa(physeq, taxa_sums(ps) != 0)
}
dist_list <- vector("list", length(dist_methods))
names(dist_list) = dist_methods
for (i in dist_methods) {
iDist <- phyloseq::distance(physeq, method=i) # so for "bray" same as vegan::vegdist(x = as(otu_table(physeq), "matrix"), method = "bray")
dist_list[[i]] = iDist
}
return(dist_list)
}
# - calculate the beta diversity distances -
dist_list <- calc_beta_div_distances(physeq_to_test, dist_methods, group_var = group_var, compare = group_var_levels) # produces objects of class "dist"
brayNotAll <- dist_list[[1]]
identical(brayAll, brayNotAll)
dist_methods = c("jsd", "unifrac")
# - calculate the beta diversity distances -
dist_list <- calc_beta_div_distances(physeq_to_test, dist_methods, group_var = group_var, compare = group_var_levels) # produces objects of class "dist"
dist_methods = c("jsd")
# - calculate the beta diversity distances -
dist_list <- calc_beta_div_distances(physeq_to_test, dist_methods, group_var = group_var, compare = group_var_levels) # produces objects of class "dist"
jsdNA <- dist_list[[1]]
calc_beta_div_distances <- function(physeq, dist_methods = c("bray"), group_var = NULL, compare = NULL) {
if (!is.null(group_var) || !is.null(compare)){
if(! group_var %in% colnames(sample_data(physeq))) {
stop("The given group_var is not a variable in the sample data of the phyloseq object.")
}
if (!all(compare %in% unique(sample_data(physeq)[[group_var]]))) {
stop("Not all names in compare are actually levels in the group_var column.")
}
keepSamples <- sample_names(physeq)[sample_data(physeq)[[group_var]] %in% compare]
physeq <- prune_samples(keepSamples, physeq)
# not sure if taxa that are not present in a single sample after the prune affect distance?:
# tested: at least not for bray curtis,
# physeq <- phyloseq::subset_taxa(physeq, taxa_sums(ps) != 0)
}
dist_list <- vector("list", length(dist_methods))
names(dist_list) = dist_methods
for (i in dist_methods) {
iDist <- phyloseq::distance(physeq, method=i) # so for "bray" same as vegan::vegdist(x = as(otu_table(physeq), "matrix"), method = "bray")
dist_list[[i]] = iDist
}
return(dist_list)
}
# - calculate the beta diversity distances -
dist_list <- calc_beta_div_distances(physeq_to_test, dist_methods, group_var = group_var, compare = group_var_levels) # produces objects of class "dist"
jsdA <- dist_list[[1]]
identical(jsdA, jsdNA)
rm(list = ls())
