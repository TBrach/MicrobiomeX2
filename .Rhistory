}
# - check that given tax_names fit to physeq and change taxa_names of physeq -
if (is.null(tax_names)){
tax_names <- paste("T", 1:ntaxa(physeq), sep = "_")
}
if(!identical(ntaxa(physeq), length(tax_names))){stop("tax_names do not fit in length to physeq")}
tax_names <- make.unique(tax_names)
taxa_names(physeq) <- tax_names
# --
# - calculate the matrix taxa_nom/(all other taxa) -
CT <- t(as(otu_table(physeq), 'matrix')) # now taxa are rows and samples are columns
CT <- CT[, group_fac %in% group_var_levels]
i <- which(rownames(CT) == taxa_nom)
if (length(i) != 1) {stop("taxa_nom not found in tax_names or tax_names not unique!")}
TbTmatrix <- apply(CT, 2, function(samp_cnts){samp_cnts[i]/samp_cnts})
# produces for each taxon (= host taxon) a TbTMatrix
# NB: there are possibly Inf, and NaN values in the matrix, specifically
# 0/x = 0, x/0 = Inf; 0/0 = NaN!
# --
TbT_DF <- as.data.frame(TbTmatrix)
TbT_DF$Taxon <- rownames(TbT_DF)
# - use taxa_den (denominator) to restrict the taxa to which taxa_nom is compared to -
if (is.null(taxa_den)) {taxa_den <- tax_names}
TbT_DF <- TbT_DF[TbT_DF$Taxon %in% taxa_den, ]
# --
# - change to long DF -
TbT_DF_l <- gather(TbT_DF, key = Sample, value = Ratio, -Taxon)
# --
# - add the group_var level information  -
LookUpDF <- data.frame(Sample = sample_names(physeq), Group = sample_data(physeq)[[group_var]])
TbT_DF_l$Group <- as.character(LookUpDF$Group[match(TbT_DF_l$Sample, LookUpDF$Sample)])
TbT_DF_l$Group <- factor(TbT_DF_l$Group, levels = group_var_levels, ordered = T)
# --
# - change all ratios where either nominator taxon or denominator taxon had count = 0 to NA -
# remember: 0/0 = NaN (not finite), 0/x = 0, x/0 = Inf
TbT_DF_l$Ratio[!is.finite(TbT_DF_l$Ratio) | TbT_DF_l$Ratio == 0] <- NA
# --
# - find taxa that would throw an error in statistical test and remove those taxa from DF -
# first find the taxa that would throw an error in t.test or wilcox.test
var_plus_length_check <- group_by(TbT_DF_l, Taxon, Group) %>% summarise(Variance = var(Ratio, na.rm = T), NotNA = sum(!is.na(Ratio)))
if (test == "t.test"){
var_plus_length_check <- dplyr::filter(var_plus_length_check, !(Variance > 0) | NotNA < 2) # variance > 0 also to remove test where host_taxon == taxon
} else if (test == "wilcox.test") {
var_plus_length_check <- dplyr::filter(var_plus_length_check, !(Variance > 0) | NotNA < 1)
}
if (nrow(var_plus_length_check) != 0) {
TbT_DF_l <- filter(TbT_DF_l, !(Taxon %in% unique(var_plus_length_check$Taxon)))
}
# --
# - use ggpubr::compare_menas to calculate all pValues of the Ratios for the different taxa_den between current group_levels -
pVals <- ggpubr::compare_means(formula = Ratio ~ Group, data = TbT_DF_l, group.by = "Taxon", method = test, p.adjust.method = p_adjust_method, symnum.args = symnum.args)
pVals <- dplyr::arrange(pVals, p)
# NB: the pVals change when you log the ratios (scale_y_log10())
TbT_DF_l$RatioLog10 <- log10(TbT_DF_l$Ratio)
pValsLog <- ggpubr::compare_means(formula = RatioLog10 ~ Group, data = TbT_DF_l, group.by = "Taxon", method = test, p.adjust.method = p_adjust_method, symnum.args = symnum.args)
pValsLog <- dplyr::arrange(pValsLog, p)
# --
# NB: I plot now for log and non log independently, even though ggpubr is so smart to change the p-values when you just use
# Tr + scale_y_log10(). I plot independently because log might change the order!
TbT_DF_l_log <- TbT_DF_l
# - order taxa based on pVals result or based on tax_order -
if (is.null(tax_order)){
TbT_DF_l$Taxon <- factor(TbT_DF_l$Taxon, levels = unique(pVals$Taxon), ordered = TRUE)
TbT_DF_l_log$Taxon <- factor(TbT_DF_l_log$Taxon, levels = unique(pValsLog$Taxon), ordered = TRUE)
} else {
if(!all(unique(pVals$Taxon) %in% tax_order)){
stop("given tax_order does not fit to tax_names")
}
TbT_DF_l$Taxon <- factor(TbT_DF_l$Taxon, levels = tax_order, ordered = TRUE)
TbT_DF_l_log$Taxon <- factor(TbT_DF_l_log$Taxon, levels = tax_order, ordered = TRUE)
}
# --
# - since you might have more than two levels in each plot you need to set the comparisons argument in stat_compare_means -
comparisonList <- get_unique_facLevel_combinations(levels(group_fac))
# --
# - plot: NB: also for non removed taxa some samples might have NA ratios that will be removed -
Tr <- ggplot(TbT_DF_l, aes(x = Group, y = Ratio, col = Group))
Tr <- Tr +
geom_violin() +
geom_point(size = 1, alpha = 0.6, position = position_jitterdodge(dodge.width = 1)) +
# scale_color_manual(values = c(color_lookup$color[i], color_lookup$color[j])) +
scale_color_manual(values = color_levels) +
facet_wrap(~ Taxon, scales = "free_y") +
xlab("") +
ylab(paste("abundance ratio of", taxa_nom, "to stated taxon")) +
theme_bw() +
theme(legend.position = "none")
Tr <- Tr + ggpubr::stat_compare_means(comparisons = comparisonList, label = "p.signif", method = test, hide.ns = hide.ns)
# Tr <- Tr + ggpubr::stat_compare_means(label = "p.signif", method = test, label.x = 1.5, hide.ns = hide.ns)
Tr1 <- ggplot(TbT_DF_l, aes(x = Group, y = Ratio, col = Group))
Tr1 <- Tr1 +
geom_boxplot(outlier.color = NA) +
geom_point(size = 1, alpha = 0.6, position = position_jitterdodge(dodge.width = 1)) +
# scale_color_manual(values = c(color_lookup$color[i], color_lookup$color[j])) +
scale_color_manual(values = color_levels) +
facet_wrap(~ Taxon, scales = "free_y") +
xlab("") +
ylab(paste("abundance ratio of", taxa_nom, "to stated taxon")) +
theme_bw() +
theme(legend.position = "none")
Tr1 <- Tr1 + ggpubr::stat_compare_means(comparisons = comparisonList, label = "p.signif", method = test, hide.ns = hide.ns)
#Tr1 <- Tr1 + ggpubr::stat_compare_means(label.x = 1.5, label = "p.signif", method = test, hide.ns = hide.ns) # p.format
Tr2 <- ggplot(TbT_DF_l_log, aes(x = Group, y = Ratio, col = Group))
Tr2 <- Tr2 +
geom_violin() +
geom_point(size = 1, alpha = 0.6, position = position_jitterdodge(dodge.width = 1)) +
# scale_color_manual(values = c(color_lookup$color[i], color_lookup$color[j])) +
scale_color_manual(values = color_levels) +
facet_wrap(~ Taxon, scales = "free_y") +
xlab("") +
ylab(paste("abundance ratio of", taxa_nom, "to stated taxon")) +
theme_bw() +
theme(legend.position = "none")
# Tr2 <- Tr2 + ggpubr::stat_compare_means(label.x = 1.5, label = "p.signif", method = test, hide.ns = hide.ns)
Tr2 <- Tr2 + scale_y_log10()
Tr2 <- Tr2 + ggpubr::stat_compare_means(comparisons = comparisonList, label = "p.signif", method = test, hide.ns = hide.ns)
Tr3 <- ggplot(TbT_DF_l_log, aes(x = Group, y = Ratio, col = Group))
Tr3 <- Tr3 +
geom_boxplot(outlier.color = NA) +
geom_point(size = 1, alpha = 0.6, position = position_jitterdodge(dodge.width = 1)) +
# scale_color_manual(values = c(color_lookup$color[i], color_lookup$color[j])) +
scale_color_manual(values = color_levels) +
facet_wrap(~ Taxon, scales = "free_y") +
xlab("") +
ylab(paste("abundance ratio of", taxa_nom, "to stated taxon")) +
theme_bw() +
theme(legend.position = "none")
# Tr3 <- Tr3 + ggpubr::stat_compare_means(label.x = 1.5, label = "p.signif", method = test, hide.ns = hide.ns)
Tr3 <- Tr3 + scale_y_log10()
Tr3 <- Tr3 + ggpubr::stat_compare_means(comparisons = comparisonList, label = "p.signif", method = test, hide.ns = hide.ns)
list(pVals = pVals, Tr = Tr, Tr1 = Tr1, pValsLog = pValsLog, Tr2 = Tr2, Tr3 = Tr3)
}
# - plot Firmicutes to all other phyla ratio plots NB: you could change taxa_den to maybe only Bacteroidetes -
FirmicutesRatioPlots <- plot_taxa_ratios_AllLevels(physeq = physeq_to_test, group_var = group_var, color_levels = color_levels1, tax_names = taxa_annotation, taxa_nom = "Firmicutes", taxa_den = NULL, tax_order = names(phylum_colors), test = "wilcox.test", p_adjust_method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))
FirmicutesRatioPlots[[1]]
FirmicutesRatioPlots[[2]]
FirmicutesRatioPlots[[3]]
FirmicutesRatioPlots[[4]]
FirmicutesRatioPlots[[5]]
color_levels
color_levels <- color_levels[1:2]
# - plot Firmicutes to all other phyla ratio plots NB: you could change taxa_den to maybe only Bacteroidetes -
FirmicutesRatioPlots <- plot_taxa_ratios_AllLevels(physeq = physeq_to_test, group_var = group_var, color_levels = color_levels, tax_names = taxa_annotation, taxa_nom = "Firmicutes", taxa_den = NULL, tax_order = names(phylum_colors), test = "wilcox.test", p_adjust_method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))
FirmicutesRatioPlots[[6]]
color_levels = color_levels
physeq = physeq_to_test
if (taxa_are_rows(physeq)) {
physeq <- t(physeq)
}
if(! group_var %in% colnames(sample_data(physeq))) {
stop("The given group_var is not a variable in the sample data of the loaded phyloseq object.")
}
if (!all(names(color_levels) %in% unique(sample_data(physeq)[[group_var]]))) {
stop("Not all names in names(color_levels)are actually levels in the group_var column.")
}
if (!(test %in% c("t.test", "wilcox.test"))) {
stop("test should be t.test or wilcox.test")
}
group_fac <- factor(sample_data(physeq)[[group_var]])
compare <- names(color_levels)
if (!is.null(compare)) {
group_var_levels <- compare
} else {
group_var_levels <- levels(group_fac)
}
# if (length(group_var_levels) != 2) {
#         stop(paste0("compare (group_var_levels) must consist of two groups - you asked for ",
#                     paste(group_var_levels, collapse = ", ")))
# }
if (!all(group_var_levels %in% levels(group_fac))) {
stop("Not all given compare (group_var_levels) are actually levels in group_var column.")
}
# - check that given tax_names fit to physeq and change taxa_names of physeq -
if (is.null(tax_names)){
tax_names <- paste("T", 1:ntaxa(physeq), sep = "_")
}
if(!identical(ntaxa(physeq), length(tax_names))){stop("tax_names do not fit in length to physeq")}
tax_names <- make.unique(tax_names)
taxa_names(physeq) <- tax_names
# --
# - calculate the matrix taxa_nom/(all other taxa) -
CT <- t(as(otu_table(physeq), 'matrix')) # now taxa are rows and samples are columns
CT <- CT[, group_fac %in% group_var_levels]
i <- which(rownames(CT) == taxa_nom)
if (length(i) != 1) {stop("taxa_nom not found in tax_names or tax_names not unique!")}
TbTmatrix <- apply(CT, 2, function(samp_cnts){samp_cnts[i]/samp_cnts})
# produces for each taxon (= host taxon) a TbTMatrix
# NB: there are possibly Inf, and NaN values in the matrix, specifically
# 0/x = 0, x/0 = Inf; 0/0 = NaN!
# --
TbT_DF <- as.data.frame(TbTmatrix)
TbT_DF$Taxon <- rownames(TbT_DF)
# - use taxa_den (denominator) to restrict the taxa to which taxa_nom is compared to -
if (is.null(taxa_den)) {taxa_den <- tax_names}
TbT_DF <- TbT_DF[TbT_DF$Taxon %in% taxa_den, ]
# --
# - change to long DF -
TbT_DF_l <- gather(TbT_DF, key = Sample, value = Ratio, -Taxon)
# --
# - add the group_var level information  -
LookUpDF <- data.frame(Sample = sample_names(physeq), Group = sample_data(physeq)[[group_var]])
TbT_DF_l$Group <- as.character(LookUpDF$Group[match(TbT_DF_l$Sample, LookUpDF$Sample)])
TbT_DF_l$Group <- factor(TbT_DF_l$Group, levels = group_var_levels, ordered = T)
# --
# - change all ratios where either nominator taxon or denominator taxon had count = 0 to NA -
# remember: 0/0 = NaN (not finite), 0/x = 0, x/0 = Inf
TbT_DF_l$Ratio[!is.finite(TbT_DF_l$Ratio) | TbT_DF_l$Ratio == 0] <- NA
# --
# - find taxa that would throw an error in statistical test and remove those taxa from DF -
# first find the taxa that would throw an error in t.test or wilcox.test
var_plus_length_check <- group_by(TbT_DF_l, Taxon, Group) %>% summarise(Variance = var(Ratio, na.rm = T), NotNA = sum(!is.na(Ratio)))
if (test == "t.test"){
var_plus_length_check <- dplyr::filter(var_plus_length_check, !(Variance > 0) | NotNA < 2) # variance > 0 also to remove test where host_taxon == taxon
} else if (test == "wilcox.test") {
var_plus_length_check <- dplyr::filter(var_plus_length_check, !(Variance > 0) | NotNA < 1)
}
if (nrow(var_plus_length_check) != 0) {
TbT_DF_l <- filter(TbT_DF_l, !(Taxon %in% unique(var_plus_length_check$Taxon)))
}
# --
# - use ggpubr::compare_menas to calculate all pValues of the Ratios for the different taxa_den between current group_levels -
pVals <- ggpubr::compare_means(formula = Ratio ~ Group, data = TbT_DF_l, group.by = "Taxon", method = test, p.adjust.method = p_adjust_method, symnum.args = symnum.args)
pVals <- dplyr::arrange(pVals, p)
pVals
TbT_DF_l$RatioLog10 <- log10(TbT_DF_l$Ratio)
pValsLog <- ggpubr::compare_means(formula = RatioLog10 ~ Group, data = TbT_DF_l, group.by = "Taxon", method = test, p.adjust.method = p_adjust_method, symnum.args = symnum.args)
pValsLog <- dplyr::arrange(pValsLog, p)
# --
# NB: I plot now for log and non log independently, even though ggpubr is so smart to change the p-values when you just use
# Tr + scale_y_log10(). I plot independently because log might change the order!
TbT_DF_l_log <- TbT_DF_l
# - order taxa based on pVals result or based on tax_order -
if (is.null(tax_order)){
TbT_DF_l$Taxon <- factor(TbT_DF_l$Taxon, levels = unique(pVals$Taxon), ordered = TRUE)
TbT_DF_l_log$Taxon <- factor(TbT_DF_l_log$Taxon, levels = unique(pValsLog$Taxon), ordered = TRUE)
} else {
if(!all(unique(pVals$Taxon) %in% tax_order)){
stop("given tax_order does not fit to tax_names")
}
TbT_DF_l$Taxon <- factor(TbT_DF_l$Taxon, levels = tax_order, ordered = TRUE)
TbT_DF_l_log$Taxon <- factor(TbT_DF_l_log$Taxon, levels = tax_order, ordered = TRUE)
}
# - since you might have more than two levels in each plot you need to set the comparisons argument in stat_compare_means -
comparisonList <- get_unique_facLevel_combinations(levels(group_fac))
comparisonList
color_levels
if (taxa_are_rows(physeq)) {
physeq <- t(physeq)
}
if(! group_var %in% colnames(sample_data(physeq))) {
stop("The given group_var is not a variable in the sample data of the loaded phyloseq object.")
}
if (!all(names(color_levels) %in% unique(sample_data(physeq)[[group_var]]))) {
stop("Not all names in names(color_levels)are actually levels in the group_var column.")
}
if (!(test %in% c("t.test", "wilcox.test"))) {
stop("test should be t.test or wilcox.test")
}
group_fac <- factor(sample_data(physeq)[[group_var]])
compare <- names(color_levels)
if (!is.null(compare)) {
group_var_levels <- compare
} else {
group_var_levels <- levels(group_fac)
}
group_var_levels
group_fac
if (!all(group_var_levels %in% levels(group_fac))) {
stop("Not all given compare (group_var_levels) are actually levels in group_var column.")
}
# - check that given tax_names fit to physeq and change taxa_names of physeq -
if (is.null(tax_names)){
tax_names <- paste("T", 1:ntaxa(physeq), sep = "_")
}
if(!identical(ntaxa(physeq), length(tax_names))){stop("tax_names do not fit in length to physeq")}
tax_names <- make.unique(tax_names)
taxa_names(physeq) <- tax_names
# --
# - calculate the matrix taxa_nom/(all other taxa) -
CT <- t(as(otu_table(physeq), 'matrix')) # now taxa are rows and samples are columns
CT <- CT[, group_fac %in% group_var_levels]
i <- which(rownames(CT) == taxa_nom)
if (length(i) != 1) {stop("taxa_nom not found in tax_names or tax_names not unique!")}
TbTmatrix <- apply(CT, 2, function(samp_cnts){samp_cnts[i]/samp_cnts})
# produces for each taxon (= host taxon) a TbTMatrix
# NB: there are possibly Inf, and NaN values in the matrix, specifically
# 0/x = 0, x/0 = Inf; 0/0 = NaN!
# --
TbT_DF <- as.data.frame(TbTmatrix)
TbT_DF$Taxon <- rownames(TbT_DF)
# - use taxa_den (denominator) to restrict the taxa to which taxa_nom is compared to -
if (is.null(taxa_den)) {taxa_den <- tax_names}
TbT_DF <- TbT_DF[TbT_DF$Taxon %in% taxa_den, ]
# --
# - change to long DF -
TbT_DF_l <- gather(TbT_DF, key = Sample, value = Ratio, -Taxon)
# --
# - add the group_var level information  -
LookUpDF <- data.frame(Sample = sample_names(physeq), Group = sample_data(physeq)[[group_var]])
TbT_DF_l$Group <- as.character(LookUpDF$Group[match(TbT_DF_l$Sample, LookUpDF$Sample)])
TbT_DF_l$Group <- factor(TbT_DF_l$Group, levels = group_var_levels, ordered = T)
# --
# - change all ratios where either nominator taxon or denominator taxon had count = 0 to NA -
# remember: 0/0 = NaN (not finite), 0/x = 0, x/0 = Inf
TbT_DF_l$Ratio[!is.finite(TbT_DF_l$Ratio) | TbT_DF_l$Ratio == 0] <- NA
var_plus_length_check <- group_by(TbT_DF_l, Taxon, Group) %>% summarise(Variance = var(Ratio, na.rm = T), NotNA = sum(!is.na(Ratio)))
if (test == "t.test"){
var_plus_length_check <- dplyr::filter(var_plus_length_check, !(Variance > 0) | NotNA < 2) # variance > 0 also to remove test where host_taxon == taxon
} else if (test == "wilcox.test") {
var_plus_length_check <- dplyr::filter(var_plus_length_check, !(Variance > 0) | NotNA < 1)
}
if (nrow(var_plus_length_check) != 0) {
TbT_DF_l <- filter(TbT_DF_l, !(Taxon %in% unique(var_plus_length_check$Taxon)))
}
# --
# - use ggpubr::compare_menas to calculate all pValues of the Ratios for the different taxa_den between current group_levels -
pVals <- ggpubr::compare_means(formula = Ratio ~ Group, data = TbT_DF_l, group.by = "Taxon", method = test, p.adjust.method = p_adjust_method, symnum.args = symnum.args)
pVals <- dplyr::arrange(pVals, p)
# NB: the pVals change when you log the ratios (scale_y_log10())
TbT_DF_l$RatioLog10 <- log10(TbT_DF_l$Ratio)
pValsLog <- ggpubr::compare_means(formula = RatioLog10 ~ Group, data = TbT_DF_l, group.by = "Taxon", method = test, p.adjust.method = p_adjust_method, symnum.args = symnum.args)
pValsLog <- dplyr::arrange(pValsLog, p)
# --
# NB: I plot now for log and non log independently, even though ggpubr is so smart to change the p-values when you just use
# Tr + scale_y_log10(). I plot independently because log might change the order!
TbT_DF_l_log <- TbT_DF_l
# - order taxa based on pVals result or based on tax_order -
if (is.null(tax_order)){
TbT_DF_l$Taxon <- factor(TbT_DF_l$Taxon, levels = unique(pVals$Taxon), ordered = TRUE)
TbT_DF_l_log$Taxon <- factor(TbT_DF_l_log$Taxon, levels = unique(pValsLog$Taxon), ordered = TRUE)
} else {
if(!all(unique(pVals$Taxon) %in% tax_order)){
stop("given tax_order does not fit to tax_names")
}
TbT_DF_l$Taxon <- factor(TbT_DF_l$Taxon, levels = tax_order, ordered = TRUE)
TbT_DF_l_log$Taxon <- factor(TbT_DF_l_log$Taxon, levels = tax_order, ordered = TRUE)
}
# - since you might have more than two levels in each plot you need to set the comparisons argument in stat_compare_means -
comparisonList <- get_unique_facLevel_combinations(levels(group_var_levels))
comparisonList
# - since you might have more than two levels in each plot you need to set the comparisons argument in stat_compare_means -
comparisonList <- get_unique_facLevel_combinations(group_var_levels)
comparisonList
plot_taxa_ratios_AllLevels <- function(physeq, group_var, color_levels, tax_names = NULL,
taxa_nom = "Firmicutes", taxa_den = NULL, test = "t.test", p_adjust_method = "fdr",
tax_order = NULL,
symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")), hide.ns = FALSE) {
if (taxa_are_rows(physeq)) {
physeq <- t(physeq)
}
if(! group_var %in% colnames(sample_data(physeq))) {
stop("The given group_var is not a variable in the sample data of the loaded phyloseq object.")
}
if (!all(names(color_levels) %in% unique(sample_data(physeq)[[group_var]]))) {
stop("Not all names in names(color_levels)are actually levels in the group_var column.")
}
if (!(test %in% c("t.test", "wilcox.test"))) {
stop("test should be t.test or wilcox.test")
}
group_fac <- factor(sample_data(physeq)[[group_var]])
compare <- names(color_levels)
if (!is.null(compare)) {
group_var_levels <- compare
} else {
group_var_levels <- levels(group_fac)
}
# if (length(group_var_levels) != 2) {
#         stop(paste0("compare (group_var_levels) must consist of two groups - you asked for ",
#                     paste(group_var_levels, collapse = ", ")))
# }
if (!all(group_var_levels %in% levels(group_fac))) {
stop("Not all given compare (group_var_levels) are actually levels in group_var column.")
}
# - check that given tax_names fit to physeq and change taxa_names of physeq -
if (is.null(tax_names)){
tax_names <- paste("T", 1:ntaxa(physeq), sep = "_")
}
if(!identical(ntaxa(physeq), length(tax_names))){stop("tax_names do not fit in length to physeq")}
tax_names <- make.unique(tax_names)
taxa_names(physeq) <- tax_names
# --
# - calculate the matrix taxa_nom/(all other taxa) -
CT <- t(as(otu_table(physeq), 'matrix')) # now taxa are rows and samples are columns
CT <- CT[, group_fac %in% group_var_levels]
i <- which(rownames(CT) == taxa_nom)
if (length(i) != 1) {stop("taxa_nom not found in tax_names or tax_names not unique!")}
TbTmatrix <- apply(CT, 2, function(samp_cnts){samp_cnts[i]/samp_cnts})
# produces for each taxon (= host taxon) a TbTMatrix
# NB: there are possibly Inf, and NaN values in the matrix, specifically
# 0/x = 0, x/0 = Inf; 0/0 = NaN!
# --
TbT_DF <- as.data.frame(TbTmatrix)
TbT_DF$Taxon <- rownames(TbT_DF)
# - use taxa_den (denominator) to restrict the taxa to which taxa_nom is compared to -
if (is.null(taxa_den)) {taxa_den <- tax_names}
TbT_DF <- TbT_DF[TbT_DF$Taxon %in% taxa_den, ]
# --
# - change to long DF -
TbT_DF_l <- gather(TbT_DF, key = Sample, value = Ratio, -Taxon)
# --
# - add the group_var level information  -
LookUpDF <- data.frame(Sample = sample_names(physeq), Group = sample_data(physeq)[[group_var]])
TbT_DF_l$Group <- as.character(LookUpDF$Group[match(TbT_DF_l$Sample, LookUpDF$Sample)])
TbT_DF_l$Group <- factor(TbT_DF_l$Group, levels = group_var_levels, ordered = T)
# --
# - change all ratios where either nominator taxon or denominator taxon had count = 0 to NA -
# remember: 0/0 = NaN (not finite), 0/x = 0, x/0 = Inf
TbT_DF_l$Ratio[!is.finite(TbT_DF_l$Ratio) | TbT_DF_l$Ratio == 0] <- NA
# --
# - find taxa that would throw an error in statistical test and remove those taxa from DF -
# first find the taxa that would throw an error in t.test or wilcox.test
var_plus_length_check <- group_by(TbT_DF_l, Taxon, Group) %>% summarise(Variance = var(Ratio, na.rm = T), NotNA = sum(!is.na(Ratio)))
if (test == "t.test"){
var_plus_length_check <- dplyr::filter(var_plus_length_check, !(Variance > 0) | NotNA < 2) # variance > 0 also to remove test where host_taxon == taxon
} else if (test == "wilcox.test") {
var_plus_length_check <- dplyr::filter(var_plus_length_check, !(Variance > 0) | NotNA < 1)
}
if (nrow(var_plus_length_check) != 0) {
TbT_DF_l <- filter(TbT_DF_l, !(Taxon %in% unique(var_plus_length_check$Taxon)))
}
# --
# - use ggpubr::compare_menas to calculate all pValues of the Ratios for the different taxa_den between current group_levels -
pVals <- ggpubr::compare_means(formula = Ratio ~ Group, data = TbT_DF_l, group.by = "Taxon", method = test, p.adjust.method = p_adjust_method, symnum.args = symnum.args)
pVals <- dplyr::arrange(pVals, p)
# NB: the pVals change when you log the ratios (scale_y_log10())
TbT_DF_l$RatioLog10 <- log10(TbT_DF_l$Ratio)
pValsLog <- ggpubr::compare_means(formula = RatioLog10 ~ Group, data = TbT_DF_l, group.by = "Taxon", method = test, p.adjust.method = p_adjust_method, symnum.args = symnum.args)
pValsLog <- dplyr::arrange(pValsLog, p)
# --
# NB: I plot now for log and non log independently, even though ggpubr is so smart to change the p-values when you just use
# Tr + scale_y_log10(). I plot independently because log might change the order!
TbT_DF_l_log <- TbT_DF_l
# - order taxa based on pVals result or based on tax_order -
if (is.null(tax_order)){
TbT_DF_l$Taxon <- factor(TbT_DF_l$Taxon, levels = unique(pVals$Taxon), ordered = TRUE)
TbT_DF_l_log$Taxon <- factor(TbT_DF_l_log$Taxon, levels = unique(pValsLog$Taxon), ordered = TRUE)
} else {
if(!all(unique(pVals$Taxon) %in% tax_order)){
stop("given tax_order does not fit to tax_names")
}
TbT_DF_l$Taxon <- factor(TbT_DF_l$Taxon, levels = tax_order, ordered = TRUE)
TbT_DF_l_log$Taxon <- factor(TbT_DF_l_log$Taxon, levels = tax_order, ordered = TRUE)
}
# --
# - since you might have more than two levels in each plot you need to set the comparisons argument in stat_compare_means -
comparisonList <- get_unique_facLevel_combinations(group_var_levels)
# --
# - plot: NB: also for non removed taxa some samples might have NA ratios that will be removed -
Tr <- ggplot(TbT_DF_l, aes(x = Group, y = Ratio, col = Group))
Tr <- Tr +
geom_violin() +
geom_point(size = 1, alpha = 0.6, position = position_jitterdodge(dodge.width = 1)) +
# scale_color_manual(values = c(color_lookup$color[i], color_lookup$color[j])) +
scale_color_manual(values = color_levels) +
facet_wrap(~ Taxon, scales = "free_y") +
xlab("") +
ylab(paste("abundance ratio of", taxa_nom, "to stated taxon")) +
theme_bw() +
theme(legend.position = "none")
Tr <- Tr + ggpubr::stat_compare_means(comparisons = comparisonList, label = "p.signif", method = test, hide.ns = hide.ns)
# Tr <- Tr + ggpubr::stat_compare_means(label = "p.signif", method = test, label.x = 1.5, hide.ns = hide.ns)
Tr1 <- ggplot(TbT_DF_l, aes(x = Group, y = Ratio, col = Group))
Tr1 <- Tr1 +
geom_boxplot(outlier.color = NA) +
geom_point(size = 1, alpha = 0.6, position = position_jitterdodge(dodge.width = 1)) +
# scale_color_manual(values = c(color_lookup$color[i], color_lookup$color[j])) +
scale_color_manual(values = color_levels) +
facet_wrap(~ Taxon, scales = "free_y") +
xlab("") +
ylab(paste("abundance ratio of", taxa_nom, "to stated taxon")) +
theme_bw() +
theme(legend.position = "none")
Tr1 <- Tr1 + ggpubr::stat_compare_means(comparisons = comparisonList, label = "p.signif", method = test, hide.ns = hide.ns)
#Tr1 <- Tr1 + ggpubr::stat_compare_means(label.x = 1.5, label = "p.signif", method = test, hide.ns = hide.ns) # p.format
Tr2 <- ggplot(TbT_DF_l_log, aes(x = Group, y = Ratio, col = Group))
Tr2 <- Tr2 +
geom_violin() +
geom_point(size = 1, alpha = 0.6, position = position_jitterdodge(dodge.width = 1)) +
# scale_color_manual(values = c(color_lookup$color[i], color_lookup$color[j])) +
scale_color_manual(values = color_levels) +
facet_wrap(~ Taxon, scales = "free_y") +
xlab("") +
ylab(paste("abundance ratio of", taxa_nom, "to stated taxon")) +
theme_bw() +
theme(legend.position = "none")
# Tr2 <- Tr2 + ggpubr::stat_compare_means(label.x = 1.5, label = "p.signif", method = test, hide.ns = hide.ns)
Tr2 <- Tr2 + scale_y_log10()
Tr2 <- Tr2 + ggpubr::stat_compare_means(comparisons = comparisonList, label = "p.signif", method = test, hide.ns = hide.ns)
Tr3 <- ggplot(TbT_DF_l_log, aes(x = Group, y = Ratio, col = Group))
Tr3 <- Tr3 +
geom_boxplot(outlier.color = NA) +
geom_point(size = 1, alpha = 0.6, position = position_jitterdodge(dodge.width = 1)) +
# scale_color_manual(values = c(color_lookup$color[i], color_lookup$color[j])) +
scale_color_manual(values = color_levels) +
facet_wrap(~ Taxon, scales = "free_y") +
xlab("") +
ylab(paste("abundance ratio of", taxa_nom, "to stated taxon")) +
theme_bw() +
theme(legend.position = "none")
# Tr3 <- Tr3 + ggpubr::stat_compare_means(label.x = 1.5, label = "p.signif", method = test, hide.ns = hide.ns)
Tr3 <- Tr3 + scale_y_log10()
Tr3 <- Tr3 + ggpubr::stat_compare_means(comparisons = comparisonList, label = "p.signif", method = test, hide.ns = hide.ns)
list(pVals = pVals, Tr = Tr, Tr1 = Tr1, pValsLog = pValsLog, Tr2 = Tr2, Tr3 = Tr3)
}
# - plot Firmicutes to all other phyla ratio plots NB: you could change taxa_den to maybe only Bacteroidetes -
FirmicutesRatioPlots <- plot_taxa_ratios_AllLevels(physeq = physeq_to_test, group_var = group_var, color_levels = color_levels, tax_names = taxa_annotation, taxa_nom = "Firmicutes", taxa_den = NULL, tax_order = names(phylum_colors), test = "wilcox.test", p_adjust_method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))
FirmicutesRatioPlots[[6]]
FirmicutesRatioPlots <- plot_taxa_ratiosSingle(physeq = physeq_to_test, group_var = group_var, color_levels = color_levels, tax_names = taxa_annotation, taxa_nom = "Firmicutes", taxa_den = NULL, tax_order = names(phylum_colors), test = "wilcox.test", p_adjust_method = "fdr", symnum.args = list(cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns")))
FimicutesRatioPlots[[6]]
FirmicutesRatioPlots[[6]]
FirmicutesRatioPlots[["pValsLog"]]
rm(list = ls())
