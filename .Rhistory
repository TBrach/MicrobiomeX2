scale_x_continuous(name="Environment", breaks=c(1,2), labels=c("A", "B"), limits = c(0.5, 2.5)) +
geom_linerange(data = rarefaction_table_unequal %>% filter(type == "estimate1"),
aes(x = ecosystem_number-0.1, ymin=richness, ymax = richness_max), lty = 1) +
geom_linerange(data = rarefaction_table_unequal %>% filter(type == "estimate2"),
aes(x = ecosystem_number+0.1, ymin=richness, ymax = richness_max), lty = 1) +
theme(legend.position="none") +
ggtitle("Bias + variance correction")
plot_d
runApp('shiny-app')
population1
input$Ca
# as for the plots she generates first populations now with a different seed
populationA <- make_community2(input$Ca, alpha_parameter = input$aa, beta_parameter = input$ab)
populationB <- make_community2(input$Cb, alpha_parameter = input$ba, beta_parameter = input$bb)
populationA$proportions
length(populationA$proportions)
results <- data.frame()
results
error <- matrix(NA, nrow = 1, ncol = 3)
error
pvalues <- matrix(NA, nrow = 3, ncol = input$repeats)
input$replicates <- 2
input$repeats <- 5
results <- data.frame()
error <- matrix(NA, nrow = 1, ncol = 3)
pvalues <- matrix(NA, nrow = 3, ncol = input$repeats)
pvalues
correct <- matrix(TRUE, nrow = 3, ncol = input$repeats)
correct
# - USER input for the error estimation part -
input$replicates <- 2
input$repeats <- 5
# - she calculates the populations again with a new seed -
set.seed(2)
populationA <- make_community2(input$Ca, alpha_parameter = input$aa, beta_parameter = input$ab)
populationB <- make_community2(input$Cb, alpha_parameter = input$ba, beta_parameter = input$bb)
results <- data.frame()
error <- matrix(NA, nrow = 1, ncol = 3)
pvalues <- matrix(NA, nrow = 3, ncol = input$repeats)
correct <- matrix(TRUE, nrow = 3, ncol = input$repeats)
# - doing for one repeat -
i = 1
i
# -- generate samples from the populations --
# generate samples
rr <- input$replicates
rr
input$repeats
rr
read_counts <- round(c(seq(from = input$na1, to = input$na2, length.out = rr),
seq(from = input$nb1, to = input$nb2, length.out = rr)))
read_counts
seq(2000, to = 4000)
seq(from = 2000, to = 4000, length.out = 2)
seq(from = 2000, to = 4000, length.out = 3)
input$replicates
seq(from = 2000, to = 4000, length.out = 5)
read_counts
samples <- list()
rr
# now generate the samples (input$replicates samples for each environment) from the populations
samples <- list()
for (k in 1:(2*rr)) {
my_name <- get(paste("population", ifelse(k <= rr, "A", "B"), sep=""))
my_sample <- sample(1:length(my_name$proportions),
size = read_counts[k], prob = my_name$proportions, replace = T)
samples[[k]] <- my_sample
}
length(samples)
samples[[4]]
sapply(samples, length)
identical(sapply(samples, length), read_counts)
read_counts
all.equal(sapply(samples, length), read_counts)
?sample_richness
# - functions for the error estimation part -
sample_richness <- function(community) {
community %>% unique %>% length
}
sample_richness(samples[[1]])
sample_richness
# -- estimate richness of the samples --
# estimate richness
cs <- lapply(samples, sample_richness) %>% unlist
cs
read_counts
rarefied_richness <- function(my_sample, level) {
my_sample %>% sample(size = level, replace = FALSE) -> rarefied_sample
rarefied_sample %>% unique %>% length
}
rarefied_richness(samples[[1]], level = 4000)
samples[[1]]
# -- estimate richness of the samples --
# estimate richness
cs <- lapply(samples, sample_richness) %>% unlist # just counting richness of the generated samples
cs_rarefied <- lapply(samples, rarefied_richness, level = min(read_counts))  %>% unlist
cs_rarefied
cs
# a very simple way to calculate the rarefied richness, just sampling the species in the samples and then count richness again
# NB: cs_rarefied is always equal (for min(read_counts)) or lower than cs
cc2 <- lapply(samples, estimate_richness_breakaway) %>% data.frame
estimate_richness_breakaway <- function(my_sample) {
my_sample %>% table %>% make_frequency_count_table -> my_count_table
result <- try(breakaway(my_count_table, output=F, plot = F, answers = T), silent = T)
if (class(result) == "list")  {
c(result$est, result$seest)
} else {
print(my_count_table)
c(NA, NA)
}
}
# a very simple way to calculate the rarefied richness, just sampling the species in the samples and then count richness again
# NB: cs_rarefied is always equal (for min(read_counts)) or lower than cs
cc2 <- lapply(samples, estimate_richness_breakaway) %>% data.frame
cc2
View(cc2)
covariate <- rep(c("A", "B"), each = rr)
covariate
lm(cs ~ covariate)
cs
cs_summary <- lm(cs ~ covariate) %>% summary
cs_summary
pvalues
cs_summary$coef
cs_summary$coef[2,4]
i
pvalues[1, i] <- cs_summary$coef[2,4]
pvalues[2, i] <- cs_r_summary$coef[2,4]
cs_r_summary <- lm(cs_rarefied ~ covariate) %>% summary # same linear analysis of the rarefied richnesses
pvalues[2, i] <- cs_r_summary$coef[2,4]
pvalues
cs_r_summary
plot(covariate, cs_rarefied)
plot(cs_rarefied)
?betta
(cc2[1, ]
)
class(cc2[1,])
rr
X = cbind("Intercept" = 1, "CovariateB" = c(rep(0, rr), rep(1, rr)
)
)
X
class(X)
bta <- betta(chats = cc2[1, ], ses = cc2[2, ], X = cbind("Intercept" = 1, "CovariateB" = c(rep(0, rr), rep(1, rr))) ) # the breakaway::betta function is used to calculate significance for the breakaway estimates
View(bta)
bta$table
bta$cov
str(bta)
cc2
bta$ssq_u
bta$homogeneity
bta$global
bta$blups
bta$table
bta <- betta(chats = cc2[1, ], ses = cc2[2, ], X = cbind("Intercept" = 1, "CovariateB" = c(rep(0, rr), rep(1, rr))) ) # the breakaway::betta function is used to calculate significance for the breakaway estimates
pvalues[3, i] <- bta$table[2,3] # the pvalue of the environment covariateA
pvalues
input$repeats
input$Ca != input$Cb
sign(cs_summary$coef[2,1]) == sign(input$Cb - input$Ca)
?sign
correct
cs_summary$coef
input$Cb
input$Ca
correct[1, i] <- sign(cs_summary$coef[2,1]) == sign(input$Cb - input$Ca) # correct stays TRUE as soon as the sign of the covariate estimate is in agreement with the real richness differences INDEPENDENT of pvalue
correct[2, i] <- sign(cs_r_summary$coef[2,1]) == sign(input$Cb - input$Ca)
correct
bta$table
bta$table[1,3]
correct[3, i] <- sign(bta$table[1,3]) == sign(input$Cb - input$Ca) # HERE was an error in the app, since bta$table[1,3] is the p-value of the covariate, it is always positive.
correct
bta$table[2,1]
correct[3, i] <- sign(bta$table[2,1]) == sign(input$Cb - input$Ca) # HERE was an error in the app, since bta$table[1,3] is the p-value of the covariate, it is always positive. It needs to be bta$table[2,1]
correct
p-values
p-values
pvalues
error
pvalues <- matrix(NA, nrow = 3, ncol = input$repeats) # so each column is a repeat, in which first row is observed richness, second rarefied richness, and third is breakaway
correct <- matrix(TRUE, nrow = 3, ncol = input$repeats)
for (i in 1:input$repeats) {
# -- generate samples from the populations --
rr <- input$replicates
read_counts <- round(c(seq(from = input$na1, to = input$na2, length.out = rr),
seq(from = input$nb1, to = input$nb2, length.out = rr)))
# so here it was: the number of reads for each sample (replicate) range from min(na1,na2) to max(na1,na2)
# now generate the samples (input$replicates samples for each environment) from the populations
samples <- list()
for (k in 1:(2*rr)) {
my_name <- get(paste("population", ifelse(k <= rr, "A", "B"), sep=""))
my_sample <- sample(1:length(my_name$proportions),
size = read_counts[k], prob = my_name$proportions, replace = T)
samples[[k]] <- my_sample
}
# NB: all.equal(sapply(samples, length), read_counts)
# ----
# -- estimate richness of the samples --
# estimate richness
cs <- lapply(samples, sample_richness) %>% unlist # just counting richness of the generated samples
cs_rarefied <- lapply(samples, rarefied_richness, level = min(read_counts))  %>% unlist
# a very simple way to calculate the rarefied richness, just sampling the species in the samples and then count richness again
# NB: cs_rarefied is always equal (for min(read_counts)) or lower than cs
cc2 <- lapply(samples, estimate_richness_breakaway) %>% data.frame # the data.frame has funny column names but does not matter, each sample one column
# ----
# -- analyse the estimated richnesses to get a p-value for each of the three methods --
covariate <- rep(c("A", "B"), each = rr)
cs_summary <- lm(cs ~ covariate) %>% summary # a linear model test whether covariate (environment has an influence on the observed sample richness)
cs_r_summary <- lm(cs_rarefied ~ covariate) %>% summary # same linear analysis of the rarefied richnesses
pvalues[1, i] <- cs_summary$coef[2,4]
pvalues[2, i] <- cs_r_summary$coef[2,4]
bta <- betta(chats = cc2[1, ], ses = cc2[2, ], X = cbind("Intercept" = 1, "CovariateB" = c(rep(0, rr), rep(1, rr))) ) # the breakaway::betta function is used to calculate significance for the breakaway estimates
pvalues[3, i] <- bta$table[2,3] # the pvalue of the environment covariateA
# ----
# -- test whether the method determined potential richness differences in the correct directions provided there was a true difference --
if (input$Ca != input$Cb) { # IN case there was a real difference in richness between the environments
correct[1, i] <- sign(cs_summary$coef[2,1]) == sign(input$Cb - input$Ca) # correct stays TRUE as soon as the sign of the covariate estimate is in agreement with the real richness differences INDEPENDENT of pvalue
correct[2, i] <- sign(cs_r_summary$coef[2,1]) == sign(input$Cb - input$Ca)
correct[3, i] <- sign(bta$table[2,1]) == sign(input$Cb - input$Ca) # HERE was an error in the app, since bta$table[1,3] is the p-value of the covariate, it is always positive. It needs to be bta$table[2,1]
}
# so at this point the repeat ends, and you have
# the p-values for the three methods
# and the correct data.frame telling you whether in case the richness indeed differs, the method determined a difference in the correct direction!
}
pvalues
correct
class(correct)
class(pvalues)
if(input$Ca == input$Cb) {
threshold <- pvalues > 0.05
} else {
threshold <- pvalues < 0.05
}
threshold
overall_correct <- threshold & correct # you needed to check whether if the pvalue was below 0.05 in case Ca != Cb that the direction was also correct
overall_correct
apply(overall_correct, 1, mean)
names(error) <- c("Raw", "Rarefied", "Corrected")
error
error <- apply(overall_correct, 1, mean)
names(error) <- c("Raw", "Rarefied", "Corrected")
error
t(error)
overall_correct
apply(overall_correct, 1, mean)
runApp('shiny-app')
runApp('shiny-app')
log(1)
log(0.8)
rm(list = ls())
# - install packages -
# NB: all packages have to be installed, usually via install.packages()
# but some you need to install via bioconductor, e.g.:
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
# --
# - load packages -
library(ggplot2); # packageVersion("ggplot2")
library(dplyr); # packageVersion("dplyr")
library(tidyr); # packageVersion("tidyr")
library(gridExtra); # packageVersion("gridExtra")
library(magrittr)
library(grid)
library(lattice)
library(phyloseq)
library(breakaway)
library(ggthemes); # packageVersion("ggthemes")
library(ggpubr); # packageVersion("ggpubr")
library(RColorBrewer)
library(lubridate)
library(knitr)
# --
input <- list()
input$Ca <- 2000 #Ca correct richness of environment A
input$Cb <- 1600 #Cb correct richness of environment B
input$aa <- 2 # see ?rbeta shape1 and shape2
input$ab <- 2
input$ba <- 1.8
input$bb <- 2
input$na1 <- 4000 # number of reads for sample 1 from environment A
input$nb1 <- 5000
input$na2 <- 6000
input$nb2 <- 7000
# - simulate the relative abundances of two communities with given number of species -
# based on rbeta function
make_community2 <- function(CC, alpha_parameter = 1, beta_parameter = 2) {
relative_proportions <- rbeta(CC, alpha_parameter, beta_parameter) # this is just a good way to get relative abundances
raw_abundances <- relative_proportions/sum(relative_proportions)
output <- list()
output$proportions <- raw_abundances
output
}
set.seed(1)
population1 <- make_community2(input$Ca, alpha_parameter = input$aa, beta_parameter = input$ab) # relative abundance of a community with input$Ca species
population2 <- make_community2(input$Cb, alpha_parameter = input$ba, beta_parameter = input$bb)
# - calculate shannon diversity of the populations
# with the relative abundances given we can also calculate the TRUE shannon diversities:
# breakaway function shannon gives same result as vegan::diversity(population1[[1]], index = "shannon")
truth <- rbind(data.frame("reads" = 0, "richness" = length(population1$proportions), "richness_max" = NA,
"shannon" = breakaway::shannon(population1$proportions), "shannon_max" = NA,
"ecosystem" =  "ecosystem1", "type" = "truth"),
data.frame("reads" = 0, "richness" = length(population2$proportions), "richness_max" = NA,
"shannon" = breakaway::shannon(population2$proportions), "shannon_max" = NA,
"ecosystem" =  "ecosystem2", "type" = "truth"))
draw_rarefaction <- function(population, pts = NA, replicates = 5, ecosystem = NA) {
rarefaction_table <- data.frame()
if (all(is.na(pts))) pts <- c(round(seq(from = 5, to = length(population$names)/100, length = 100)),
round(seq(from = length(population$names)/100, to = length(population$names)/10, length = 100)),
round(seq(from = length(population$names)/10, to = length(population$names)/4, length = 100)),
round(seq(from = length(population$names)/4, to = length(population$names), length = 10)))
who <- replicate(replicates, sample(population$names, length(population$names), replace = F))
for (i in pts) {
subsample_diversity <- rep(NA, replicates)
subsample_shannon <- rep(NA, replicates)
for (j in 1:replicates) {
subsample <- who[1:i, j]
subsample_diversity[j] <- length(unique(subsample))
community <- c(as.matrix(table(subsample)))
proportions <- community/sum(community)
subsample_shannon[j] <- breakaway::shannon(proportions)
}
rarefaction_table %<>% rbind(data.frame("reads" = i,
"richness" = min(subsample_diversity), "richness_max" = max(subsample_diversity),
"shannon" = min(subsample_shannon), "shannon_max" = max(subsample_shannon),
"ecosystem" = ecosystem, "type" = "rcurve"))
}
rarefaction_table
}
get_point <- function(ecosystem, read, label) {
read <- round(read)
my_population <- get(paste("population", ecosystem, sep="")) # so either population1 or population2, i.e. the simulated proportions
ecosystem_name <- paste("ecosystem", ecosystem, sep="")
subsample <- sample(x = c(1:length(my_population$proportions)),
size = read, prob = my_population$proportions, replace = T) # the Ids of the species,
point <- data.frame("reads" = read,
"richness" = length(unique(subsample)), "richness_max" = NA,
"shannon" = breakaway::shannon(c(as.matrix(table(subsample)))/sum(c(as.matrix(table(subsample))))), "shannon_max" = NA,
"ecosystem" = ecosystem_name, "type" = "observation")
subsample1 <- list()
subsample1$names <- subsample
subsample1$proportions <- c(as.matrix(table(subsample)))/sum(c(as.matrix(table(subsample)))) #NB that length(subsample1$proportions) is the richness of the sample
# plot(log10(sort(subsample1$proportions))) # shows you how sampling changes the picture
# draws the rarefaction curve
rarefied_sample <- draw_rarefaction(subsample1, replicates = 1, pts = seq(from = 1, to = read, length = 100),
ecosystem = ecosystem_name)
rarefied_sample$type <- paste("rarefied_sample", label, sep="") # rarefied_sample shows richness and shannon at each rarefaction step
xx <- subsample %>% table %>% make_frequency_count_table # note here the usually very high number of singletons
estimate <- xx %>% breakaway(answers = T, plot = F, output=F) %$% est
# here is the estimate based on the frequency input, equal to:
# ba <- breakaway(xx, answers = T, plot = F, output = F)
# estimate <- ba$est
error <- xx %>% breakaway(answers = T, plot = F, output=F) %$% seest
richness_estimate <- c(estimate - 2*error, estimate + 2*error)
estimate <- data.frame("reads" = read,
"richness" = richness_estimate[1], "richness_max" = richness_estimate[2],
"shannon" = 0, "shannon_max" = 100000,
"ecosystem" = ecosystem_name, "type" = paste("estimate", label, sep=""))
rbind(point, rarefied_sample, estimate)
}
observations <- rbind(get_point(ecosystem = 1, read = input$na1, label = 1),
get_point(1, input$na2, 2),
get_point(2, input$nb1, 1),
get_point(2, input$nb2, 2))
rarefaction_level <- observations %>% filter(type == "observation") %>% select(reads) %>% min # find the lowest number of reads used in the four smaples
rarefaction_table <- rbind(observations, truth)
rarefaction_table %>% select(ecosystem) %>% unlist %>% substring(10, 11) %>% as.numeric -> rarefaction_table$ecosystem_number
rarefaction_table_unequal <- rarefaction_table
# - now she generates the different plots -
plot_base <- ggplot(data = rarefaction_table_unequal, aes(col = ecosystem)) +
theme_bw() +
geom_hline(data = rarefaction_table_unequal %>% filter(type == "truth"),
aes(yintercept=richness, col = ecosystem, lty = ecosystem)) +
scale_linetype_manual(guide = "none", values=c("twodash", "dotted")) +
labs(x="No. reads", y="Taxonomic richness",col = "") +
coord_cartesian(ylim=c(0, max(input$Ca, input$Cb)*1.1))
plot_a <- plot_base +
xlim(0, 1.5*max(input$na1, input$na2, input$nb1, input$nb2)) +
geom_ribbon(data = rarefaction_table_unequal %>% filter(type == "rcurve"),
aes(x=reads, ymin=richness, ymax=richness_max, col = ecosystem, fill = ecosystem), alpha = 0, linetype = 0) +
geom_point(data = rarefaction_table_unequal %>% filter(type == "observation"),
aes(x=reads, y=richness, col = ecosystem))+
geom_line(data = rarefaction_table_unequal %>% filter(type == "rarefied_sample1"),
aes(x=reads, y=richness, col = ecosystem)) +
geom_line(data = rarefaction_table_unequal %>% filter(type == "rarefied_sample2"),
aes(x=reads, y=richness, col = ecosystem)) +
theme(legend.position = c(0.7, 0.2), legend.text=element_text(size=7))  +
scale_color_discrete(name="",
breaks=c("ecosystem1", "ecosystem2"),
labels=c("Environment A", "Environment B")) +
guides(fill=FALSE)+
geom_text(data = data.frame("x"=(input$nb1), "y"= max(input$Ca, input$Cb)*1.05), aes(x,y),
col = "black", label = "True taxonomic richnesses", cex = 3) +
ggtitle("Rarefaction curve for alpha diversity")
plot_b <- plot_base +
geom_point(data = rarefaction_table_unequal %>% filter(type == "observation"),
aes(x=ecosystem_number+c(-0.1, 0.1), y=richness, col = ecosystem)) +
scale_x_continuous(name="Environment", breaks=c(1,2), labels=c("A", "B"), limits = c(0.5, 2.5)) +
theme(legend.position="none") +
ggtitle("Raw alpha diversity")
plot_c <- plot_base +
scale_x_continuous(name="Environment", breaks=c(1,2), labels=c("A", "B"), limits = c(0.5, 2.5)) +
geom_point(data = rarefaction_table_unequal %>% filter(type %in% c("rarefied_sample1", "rarefied_sample2"))  %>%
group_by(ecosystem, ecosystem_number, type)  %>%
filter(reads <= rarefaction_level) %>%
filter(reads == max(reads)), # so here she picks the rarefied richness from the rarefaction curves
aes(x=ecosystem_number+c(-0.1, 0.1), y=richness, col = ecosystem))   +
theme(legend.position="none") +
ggtitle("Rarefield alpha diversity")
plot_d <- plot_base +
scale_x_continuous(name="Environment", breaks=c(1,2), labels=c("A", "B"), limits = c(0.5, 2.5)) +
geom_linerange(data = rarefaction_table_unequal %>% filter(type == "estimate1"),
aes(x = ecosystem_number-0.1, ymin=richness, ymax = richness_max), lty = 1) +
geom_linerange(data = rarefaction_table_unequal %>% filter(type == "estimate2"),
aes(x = ecosystem_number+0.1, ymin=richness, ymax = richness_max), lty = 1) +
theme(legend.position="none") +
ggtitle("Bias + variance correction")
final_outputPlot <- grid.arrange(grobs = list(plot_a, plot_b, plot_c, plot_d),
layout_matrix = matrix(c(1,1,2,3,4), nrow = 1))
# - USER input for the error estimation part -
input$replicates <- 2
input$repeats <- 5
# - functions for the error estimation part -
sample_richness <- function(community) {
community %>% unique %>% length
}
rarefied_richness <- function(my_sample, level) {
my_sample %>% sample(size = level, replace = FALSE) -> rarefied_sample
rarefied_sample %>% unique %>% length
}
estimate_richness_breakaway <- function(my_sample) {
my_sample %>% table %>% make_frequency_count_table -> my_count_table
result <- try(breakaway(my_count_table, output=F, plot = F, answers = T), silent = T)
if (class(result) == "list")  {
c(result$est, result$seest)
} else {
print(my_count_table)
c(NA, NA)
}
}
# - she calculates the populations again with a new seed -
set.seed(2)
populationA <- make_community2(input$Ca, alpha_parameter = input$aa, beta_parameter = input$ab)
populationB <- make_community2(input$Cb, alpha_parameter = input$ba, beta_parameter = input$bb)
pvalues <- matrix(NA, nrow = 3, ncol = input$repeats) # so each column is a repeat, in which first row is observed richness, second rarefied richness, and third is breakaway
correct <- matrix(TRUE, nrow = 3, ncol = input$repeats)
for (i in 1:input$repeats) {
# -- generate samples from the populations --
rr <- input$replicates
read_counts <- round(c(seq(from = input$na1, to = input$na2, length.out = rr),
seq(from = input$nb1, to = input$nb2, length.out = rr)))
# so here it was: the number of reads for each sample (replicate) range from min(na1,na2) to max(na1,na2)
# now generate the samples (input$replicates samples for each environment) from the populations
samples <- list()
for (k in 1:(2*rr)) {
my_name <- get(paste("population", ifelse(k <= rr, "A", "B"), sep=""))
my_sample <- sample(1:length(my_name$proportions),
size = read_counts[k], prob = my_name$proportions, replace = T)
samples[[k]] <- my_sample
}
# NB: all.equal(sapply(samples, length), read_counts)
# ----
# -- estimate richness of the samples --
# estimate richness
cs <- lapply(samples, sample_richness) %>% unlist # just counting richness of the generated samples
cs_rarefied <- lapply(samples, rarefied_richness, level = min(read_counts))  %>% unlist
# a very simple way to calculate the rarefied richness, just sampling the species in the samples and then count richness again
# NB: cs_rarefied is always equal (for min(read_counts)) or lower than cs
cc2 <- lapply(samples, estimate_richness_breakaway) %>% data.frame # the data.frame has funny column names but does not matter, each sample one column
# ----
# -- analyse the estimated richnesses to get a p-value for each of the three methods --
covariate <- rep(c("A", "B"), each = rr)
cs_summary <- lm(cs ~ covariate) %>% summary # a linear model test whether covariate (environment has an influence on the observed sample richness)
cs_r_summary <- lm(cs_rarefied ~ covariate) %>% summary # same linear analysis of the rarefied richnesses
pvalues[1, i] <- cs_summary$coef[2,4]
pvalues[2, i] <- cs_r_summary$coef[2,4]
bta <- betta(chats = cc2[1, ], ses = cc2[2, ], X = cbind("Intercept" = 1, "CovariateB" = c(rep(0, rr), rep(1, rr))) ) # the breakaway::betta function is used to calculate significance for the breakaway estimates
pvalues[3, i] <- bta$table[2,3] # the pvalue of the environment covariateA
# ----
# -- test whether the method determined potential richness differences in the correct directions provided there was a true difference --
if (input$Ca != input$Cb) { # IN case there was a real difference in richness between the environments
correct[1, i] <- sign(cs_summary$coef[2,1]) == sign(input$Cb - input$Ca) # correct stays TRUE as soon as the sign of the covariate estimate is in agreement with the real richness differences INDEPENDENT of pvalue
correct[2, i] <- sign(cs_r_summary$coef[2,1]) == sign(input$Cb - input$Ca)
correct[3, i] <- sign(bta$table[2,1]) == sign(input$Cb - input$Ca) # HERE was an error in the app, since bta$table[1,3] is the p-value of the covariate, it is always positive. It needs to be bta$table[2,1]
}
# so at this point the repeat ends, and you have
# the p-values for the three methods
# and the correct data.frame telling you whether in case the richness indeed differs, the method determined a difference in the correct direction!
}
correct
if(input$Ca == input$Cb) {
threshold <- pvalues > 0.05
} else {
threshold <- pvalues < 0.05
}
overall_correct <- threshold & correct # you needed to check whether if the pvalue was below 0.05 in case Ca != Cb that the direction was also correct
error <- apply(overall_correct, 1, mean)
names(error) <- c("Raw", "Rarefied", "Corrected")
FinalTable <- t(error) # is what will be shown as the table
FinalTable
threshold
class(trehsold)
class(threshold)
correct
FinalTable
input$replicates
# added rownames to make the tables more clear
colnames(correct)
# added rownames to make the tables more clear
colnames(correct) <- paste("repeat_", 1:input$repeats, sep = "")
correct
rm(list = ls())
