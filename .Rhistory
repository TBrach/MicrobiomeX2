df_in$Time <- lubridate::parse_date_time(df_in$Time, orders = "HM", tz = "CET")
str(df_in)
df_in$Time <- HM(df_in$Time)
?HM
?hm
df_in$Time <- hm(df_in$Time)
df_in <- read.csv2(file = file.path(datapath, "BSC.csv"), sep = ";", header = TRUE, stringsAsFactors = FALSE)
colIndexes <- match(c("Date", "Time", "Systolic", "Diastolic", "Heart", "Arm", "Comment"), colnames(df_in))
df_in <- df_in[, colIndexes]
df_in$Date <- lubridate::parse_date_time(df_in$Date, orders = "dmy", tz = "CET")
hm(df_in$Time)
lubridate::hm(df_in$Time)
colnames(df_in)
View(df_in)
str(df_in)
df_in <- read.csv2(file = file.path(datapath, "BSC.csv"), sep = ";", header = TRUE, stringsAsFactors = FALSE)
colIndexes <- match(c("Date", "Time", "Systolic", "Diastolic", "Heart", "Arm", "Comment"), colnames(df_in))
df_in <- df_in[, colIndexes]
df_in$Date <- lubridate::parse_date_time(df_in$Date, orders = "dmy", tz = "CET")
df_in$Time <- lubridate::hm(df_in$Time)
df_in$Systolic <- as.numeric(df_in$Systolic)
df_in$Diastolic <- as.numeric(df_in$Diastolic)
df_in$Heart <- as.numeric(df_in$Heart)
str(df_in)
View(df_in)
as.character(df_in$Time)
update(df_in$Date, hour = hour(df_in$Time), minute = minute(df_in$Time))
df_in$Date + df_in$Time
df_in <- read.csv2(file = file.path(datapath, "BSC.csv"), sep = ";", header = TRUE, stringsAsFactors = FALSE)
colIndexes <- match(c("Date", "Time", "Systolic", "Diastolic", "Heart", "Arm", "Comment"), colnames(df_in))
df_in <- df_in[, colIndexes]
df_in$Date <- lubridate::parse_date_time(df_in$Date, orders = "dmy", tz = "CET")
df_in$DateTime <- df_in$Date + lubridate::hm(df_in$Time)
df_in$Systolic <- as.numeric(df_in$Systolic)
df_in$Diastolic <- as.numeric(df_in$Diastolic)
df_in$Heart <- as.numeric(df_in$Heart)
View(df_in)
df_in$DateTime[1] > df_in$DateTime[nrow(df_in)]
df_in <- read.csv2(file = file.path(datapath, "BSC.csv"), sep = ";", header = TRUE, stringsAsFactors = FALSE)
colIndexes <- match(c("Date", "Time", "Systolic", "Diastolic", "Heart", "Arm", "Comment"), colnames(df_in))
df_in <- df_in[, colIndexes]
df_in$Date <- lubridate::parse_date_time(df_in$Date, orders = "dmy", tz = "CET")
df_in$DateTime <- df_in$Date + lubridate::hm(df_in$Time)
df_in$Systolic <- as.numeric(df_in$Systolic)
df_in$Diastolic <- as.numeric(df_in$Diastolic)
df_in$Heart <- as.numeric(df_in$Heart)
df_in$Arm <- as.character(df_in$Arm)
df_in$comment <- as.character(df_in$Comment)
df_in <- dplyr::select(df_in, DateTime, Date:Comment)
str(df_in)
DFaPlot <- df_in
colnames(DFaPlot)
DFaPlot <- gather(DFaPlot, key = "Measure", value = "Value", Systolic:Heart)
library(shiny)
library(lubridate)
library(tidyr)
library(dplyr)
# library(rdrop2)
library(ggplot2)
library(plotly)
DFaPlot <- gather(DFaPlot, key = "Measure", value = "Value", Systolic:Heart)
View(DFaPlot)
Tr <- ggplot(DFaPlot, aes(x = DateTime, y = Measure, col = Measure))
Tr +
geom_point(size = 1, alpha = 0.8) +
facet_wrap(~ Measure)
Tr <- ggplot(DFaPlot, aes(x = DateTime, y = Value, col = Measure))
Tr +
geom_point(size = 1, alpha = 0.8) +
facet_wrap(~ Measure)
Tr +
geom_point(size = 1, alpha = 0.8) +
facet_wrap(~ Measure, scales = "free.y")
Tr +
geom_point(size = 1, alpha = 0.8) +
facet_wrap(~ Measure, scales = "free_y")
Tr +
geom_point(size = 1, alpha = 0.8) +
facet_wrap(~ Measure, scales = "free_y") +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE)
measure_colors <- c("Systolic" = cbPalette[7], "Diastolic" = cbPalette[2], "Heart" = cbPalette[4])
Tr <- ggplot(DFaPlot, aes(x = DateTime, y = Value, col = Measure))
Tr +
geom_point(size = 1, alpha = 0.8) +
facet_wrap(~ Measure) +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE) +
scale_color_manual("", values = measure_colors) +
theme_bw()
DFaPlot$Measure <- factor(DFaPlot$Measure, levels = c("Systolic", "Diastolic", "Heart"), ordered = TRUE)
Tr <- ggplot(DFaPlot, aes(x = DateTime, y = Value, col = Measure))
Tr +
geom_point(size = 1, alpha = 0.8) +
# facet_wrap(~ Measure) +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE) +
scale_color_manual("", values = measure_colors) +
theme_bw()
DFaPlot1 <- filter(DFaPlot, Measure %in% c("Systolic", "Diastolic"))
Tr <- ggplot(DFaPlot1, aes(x = DateTime, y = Value, col = Measure))
Tr +
geom_point(size = 1, alpha = 0.8) +
# facet_wrap(~ Measure) +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE) +
scale_color_manual("", values = measure_colors) +
theme_bw() +
theme(legend.position = "none")
DFaPlot1 <- filter(DFaPlot, Measure %in% c("Systolic", "Diastolic"))
DFaPlot2 <- filter(DFaPlot, Measure %in% c("Heart"))
Tr <- ggplot(DFaPlot1, aes(x = DateTime, y = Value, col = Measure))
Tr <- Tr +
geom_point(size = 1, alpha = 0.8) +
# facet_wrap(~ Measure) +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE) +
scale_color_manual("", values = measure_colors) +
theme_bw() +
xlab("") +
ylab("pressure in mmHg")
Tr
DFaPlot2 <- filter(DFaPlot, Measure %in% c("Heart"))
Tr1 <- ggplot(DFaPlot2, aes(x = DateTime, y = Value, col = Measure))
Tr1 +
geom_point(size = 1, alpha = 0.8) +
# facet_wrap(~ Measure) +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE) +
scale_color_manual("", values = measure_colors) +
theme_bw() +
xlab("")
Tr <- ggplot(DFaPlot1, aes(x = DateTime, y = Value, col = Measure))
Tr <- Tr +
geom_point(size = 1, alpha = 0.8) +
# facet_wrap(~ Measure) +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE) +
scale_color_manual("", values = measure_colors) +
theme_bw() +
xlab("") +
ylab("pressure in mmHg")
Tr1 <- ggplot(DFaPlot2, aes(x = DateTime, y = Value, col = Measure))
Tr1 <- Tr1 +
geom_point(size = 1, alpha = 0.8) +
# facet_wrap(~ Measure) +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE) +
scale_color_manual("", values = measure_colors) +
theme_bw() +
xlab("") +
theme(legend.position = "none") +
ylab("heartbeats per minute")
Tr
Tr1
library(gridExtra)
grid.arrange(Tr, Tr1, nrow = 2)
Tr <- ggplot(DFaPlot, aes(x = DateTime, y = Value, col = Measure))
Tr +
geom_point(size = 1, alpha = 0.8) +
facet_wrap(~ Measure, ncol = 1) +
geom_smooth(aes(group = Measure), method = "lm", se = TRUE) +
scale_color_manual("", values = measure_colors) +
theme_bw() +
xlab("")
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/BloodPressureViewer/app_bloodpressureViewer.R')
?plotlyOutput
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/BloodPressureViewer/app_bloodpressureViewer.R')
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/BloodPressureViewer/app_bloodpressureViewer.R')
?format
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/BloodPressureViewer/app_bloodpressureViewer.R')
datapath <- "/Users/jvb740/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/BloodPressureViewer"
df_in <- read.csv2(file = file.path(datapath, "BSC.csv"), sep = ";", header = TRUE, stringsAsFactors = FALSE)
colIndexes <- match(c("Date", "Time", "Systolic", "Diastolic", "Heart", "Arm", "Comment"), colnames(df_in))
df_in <- df_in[, colIndexes]
df_in$Date <- lubridate::parse_date_time(df_in$Date, orders = "dmy", tz = "CET")
df_in$DateTime <- df_in$Date + lubridate::hm(df_in$Time)
df_in$Systolic <- as.numeric(df_in$Systolic)
df_in$Diastolic <- as.numeric(df_in$Diastolic)
df_in$Heart <- as.numeric(df_in$Heart)
df_in$Arm <- as.character(df_in$Arm)
df_in$comment <- as.character(df_in$Comment)
df_in <- dplyr::select(df_in, DateTime, Date:Comment)
DFaPlot <- df_in
DFaPlot <- gather(DFaPlot, key = "Measure", value = "Value", Systolic:Heart)
DFaPlot$Measure <- factor(DFaPlot$Measure, levels = c("Systolic", "Diastolic", "Heart"), ordered = TRUE)
colnames(DFaPlot)
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/BloodPressureViewer/app_bloodpressureViewer.R')
DFaPlot$DateTime
format(DFaPlot$DateTime)
format(DFaPlot$DateTime)
class(format(DFaPlot$DateTime))
runApp('~/Coursera_MOOC/20161202_LearningShiny_FantasySports/shinyy/Apps/Shinyappsio/BloodPressureViewer/app_bloodpressureViewer.R')
rm(list = ls())
rm(list = ls())
# - install packages -
# NB: all packages have to be installed, usually via install.packages()
# some packages you need to install via bioconductor, e.g.:
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
# --
# - load packages -
library(phyloseq); # packageVersion("phyloseq")
library(dada2); # packageVersion("dada2")
library(vegan); # packageVersion("vegan")
library(ggplot2); # packageVersion("ggplot2")
library(dplyr); # packageVersion("dplyr")
library(tidyr); # packageVersion("tidyr")
library(gridExtra); # packageVersion("gridExtra")
library(xtable); # packageVersion("xtable")
library(RVAideMemoire); #packageVersion("RVAideMemoire")
library(viridis); # packageVersion("viridis")
library(scales); # packageVersion("scales") # for the oob = squish option in gradient plots
library(ggthemes); # packageVersion("ggthemes")
library(DESeq2); # packageVersion("DESeq2")
library(ggpubr); # packageVersion("ggpubr")
library(RColorBrewer)
library(pheatmap)
library(grid)
library(breakaway)
library(bookdown)
# library(coin) # only needed if using test_differential_abundance_WilcoxonsingleManiCoin
# - packaged from Mani's analysis that I could add if needed-
# library(cowplot)
# library(ade4)
# library(ggrepel)
# library(ggforce)
# library(kableExtra)
# library(bindrcpp)
# library(stringr)
# library(BiocParallel)
# library(microbiomeX)
# --
# - source all functions -
functionpath <- "./Functions"
source(file.path(functionpath, "_n_000_helper_functions.R"))
source(file.path(functionpath, "_n_010_explore_ps_functions.R"))
source(file.path(functionpath, "_n_020_alpha_diversity_functions.R"))
source(file.path(functionpath, "_n_030_preprocess_filtering_functions.R"))
source(file.path(functionpath, "_n_040_beta_diversity_functions.R"))
source(file.path(functionpath, "_n_050_diff_abundance_functions.R"))
source(file.path(functionpath, "_n_060_phylum_analysis_functions.R"))
# --
# - load your phyloseq object -
# NB: USER INPUTPS
name_phyloseq_rds <- "physeq_microdiab_ngt_Men.rds"
# NB: USER INPUT
datapath <- "./Example_phyloseq_objects"
# Test your input:
if(! file.exists(file.path(datapath, name_phyloseq_rds))){
stop("The given path/file to your phyloseq object does not exist.")
}
ps <- readRDS(file.path(datapath, name_phyloseq_rds))
# - Define the group variable for sample comparisons -
# NB: USER INPUT
group_var <- "Country" # MANDATORY: a variable in sample_data(ps) based on which samples will be compared
# Test your input:
if(! group_var %in% colnames(sample_data(ps))) {
stop("The given group_var is not a variable in the sample data of the loaded phyloseq object.")
}
# --
# - Define the two levels in your group_var that you want to compare -
# NB: USER INPUT
group_var_levels <- c("IN", "DK") # defines the order of the groups in all plots. If set to NULL:
if (is.null(group_var_levels)) {
group_var_levels <- unique(sample_data(ps)[[group_var]])
}
# Test your input:
if (!all(group_var_levels %in% unique(sample_data(ps)[[group_var]]))) {
stop("Not all given group_var_levels are actually levels in group_var column.")
}
if (length(group_var_levels) != 2) {
stop("Sorry, for MicrobiomeX2 group_var_levels needs to consist of exactly 2 levels.")
}
# make sure sample_data(ps) is a factor (not totally necessary but in case there is no ordering in one of the functions)
sample_data(ps)[[group_var]] <- factor(sample_data(ps)[[group_var]], levels = c(group_var_levels, setdiff(unique(sample_data(ps)[[group_var]]), group_var_levels)), ordered = TRUE)
# --
# - Set the colors representing the groups in your group_var_levels -
# NB: so also color_levels must consist of exactly two colors
# NB: USER INPUT
color_levels <- c(cbPalette[2], cbPalette[4]) # choose your preferred colors for each group in your group_var. If set to NULL:
if (is.null(color_levels)) {
color_levels <- c(cbPalette[2], cbPalette[4])
}
# Test your input:
if (length(color_levels) != length(group_var_levels)) {
stop("The number of colors in the given color_levels did not fit to group_var_levels.")
}
if (!all(areColors(color_levels))) {
stop("Stopped because not all entries in color_levels were valid R colors.")
}
names(color_levels) <- group_var_levels
# --
# - optional: use another variable in sample_data(ps) as shape in some of the plots -
# NB: user input
shape <- "Gender"
# Test your input:
if (!is.null(shape)) {
if (! shape %in% colnames(sample_data(ps))) {
stop("The given shape is not a variable in the sample data of the loaded phyloseq object.")
}
}
# --
# - Set the taxonomic_level for the analysis -
# NB: You can choose all levels within colnames(tax_table(ps))
# phyloseq::taxglom will be used to adjust the phyloseq object to the chosen taxonomic_level.
# if you set taxonomic_level to NULL, all taxa will be analysed (i.e. strain/species/ASV level analysis)
# NB user input
taxonomic_level <- "Species"
# NB user input
phylum_NA_removal <- "no" # if yes you remove all taxa for which Phylum = NA before the analyses
# Test your input:
if (!is.null(taxonomic_level) && !(taxonomic_level %in% colnames(tax_table(ps)))){
stop("You provided a taxonomic_level that is not present in the tax_table of the loaded phyloseq object.")
}
# --
# - Filtering inputs -
# NB: user input
prevalence <- 5 # in percent, for prevalence filtering of taxa
# NB: user input
min_obs <- 0L # in counts, a taxon will be considered present (for prevalence) if count > min_obs
# NB: user input
taxa_sums_quantile <- 100 # in percent, taxa whose taxa_sums are above this threshold will be kept even if they do not pass prevalence filter
# Test filtering inputs and set invalid inputs to defaults
if (!is.numeric(prevalence) || prevalence < 0 || prevalence > 100) {
prevalence <- 0
}
if (!is.numeric(min_obs)) {
min_obs <- 0L
}
if (!is.numeric(taxa_sums_quantile) || taxa_sums_quantile < 0 || taxa_sums_quantile > 100) {
taxa_sums_quantile <- 100
}
# --
# - Alpha diversity and rarifaction inputs -
# NB: user input
alpha_div_measures <- c("Observed", "Shannon") # ?phyloseq::estimate_richness: may include c("Observed", "Chao1", "ACE", "Shannon", "Simpson", "InvSimpson", "Fisher")
# NB: user input
seed <- 1234 # for reproducibility of rarefaction curves
# NB: user input
step_size <- 200 # steps in sample_sums for rarefaction curves
# NB: user input
rare_level <- NULL # sample_sums/total_counts level to which rarefaction is perforemd, if NULL, min(sample_sums(ps)) is used!
# NB: user input
rare_max_total <- NULL # maximal sample_sums/total_counts value to which rarefaction curves are calculated, if NULL: quantile(sample_sums(ps), probs = .25) is used
# Test alpha-diversity inputs and set invalid inputs to defaults
if (! all(alpha_div_measures %in% c("Observed", "Chao1", "ACE", "Shannon", "Simpson", "InvSimpson", "Fisher"))) {
alpha_div_measures <- c("Observed", "Shannon")
}
if (!is.numeric(seed)) {
seed <- 1234
}
if (!is.numeric(step_size)) {
step_size <- 200
}
if (!is.numeric(rare_level)) {
rare_level <- NULL # will be changed to min(sample_sums(ps))
}
if (!is.numeric(rare_max_total)) {
rare_max_total <- NULL # quantile(sample_sums(ps), probs = .25)
}
# --
# - beta diversity inputs -
dist_methods <- c("bray", "jsd") # otions: see unlist(phyloseq::distanceMethodList)
coord_cor <- FALSE # adjustment of the axis representation in ordination plots
# Test beta diversity inputs and set invalid inputs to defaults
if (! all(dist_methods %in% unlist(phyloseq::distanceMethodList))) {
dist_methods <- c("bray", "jsd")
}
if (! is.logical(coord_cor)){
coord_cor <- FALSE
}
# --
# - remove taxa not present in a single sample -
ps <- phyloseq::subset_taxa(ps, taxa_sums(ps) != 0)
# --
taxa_before <- ntaxa(ps)
ps
# - remove taxa with Kingdom == NA -
ps <- phyloseq::subset_taxa(ps, !is.na(Kingdom))
ps
5 + 3
group_var <- "Group"
?estimateSizeFactors
gm_own
# generate a new phyloseq object that contains only taxa with at least one zero count in one of the samples
count_table <- t(as(otu_table(ps), "matrix")) # taxa are rows now
sum(rowSums(count_table == 0) > 0)
ps
ps2 <- prune_taxa(taxa = rowSums(count_table == 0) > 0, x = ps)
ps2
DES = phyloseq_to_deseq2(ps2, formula(paste("~", group_var)))
group_var <- "Country"
DES = phyloseq_to_deseq2(ps2, formula(paste("~", group_var)))
SS <- as(sample_data(ps), "data.frame")
View(SS)
str(SS)
table(SS$Country)
group_var
SS$Country <- factor(SS$Country, ordered = FALSE)
sample_data(ps) <- SS
ps2 <- prune_taxa(taxa = rowSums(count_table == 0) > 0, x = ps)
ps2
DES = phyloseq_to_deseq2(ps2, formula(paste("~", group_var)))
estimateSizeFactors(DES, type = "ratio")
body(gm_own)
ti <- c(10, 0, 10, 0, 10)
gm_own(ti)
gm_own(ti, zeros.count = FALSE)
ti <- c(100, 0, 100, 0, 100)
gm_own(ti, zeros.count = FALSE)
gm_own(ti, zeros.count = TRUE)
100^3
(1e6)^(1/5)
100/15.8489
GM_referenceSample <- apply(otu_table(ps2), 2, gm_own, zeros.count = FALSE)
GM_referenceSample_zerosCount <- apply(otu_table(ps2), 2, gm_own, zeros.count = TRUE)
SFs <- sizeFactors(estimateSizeFactors(DES, type = "ratio", geoMeans = GM_referenceSample))
SFs_zerosCount <- sizeFactors(estimateSizeFactors(DES, type = "ratio", geoMeans = GM_referenceSample_zerosCount))
SFs2 <- sizeFactors(estimateSizeFactors(DES, type = "poscounts"))
identical(SFs_zerosCount, SFs2) # TRUE
plot(SFs, SFs_zerosCount)
SFs
SFs_zerosCount
SFs_zerosCount-SFs
GM_referenceSample/GM_referenceSample_zerosCount
range(GM_referenceSample/GM_referenceSample_zerosCount)
GM_referenceSample <- apply(otu_table(ps2), 2, gm_own, zeros.count = FALSE)
GM_referenceSample_zerosCount <- apply(otu_table(ps2), 2, gm_own, zeros.count = TRUE)
range(GM_referenceSample/GM_referenceSample_zerosCount)
SFs <- sizeFactors(estimateSizeFactors(DES, type = "ratio", geoMeans = GM_referenceSample))
SFs_zerosCount <- sizeFactors(estimateSizeFactors(DES, type = "ratio", geoMeans = GM_referenceSample_zerosCount))
range(SFs/SFs_zerosCount)
# takes about a minute or two on my MAC:
SF_iterate <- sizeFactors(estimateSizeFactors(DES, type = "iterate"))
# GM_referenceSample is always equal or bigger than GM_referenceSample_zerosCount
range(GM_referenceSample/GM_referenceSample_zerosCount)
# I would therefore expect that all SFs (zeros.count = FALSE) would be smaller than SFs_zerosCount, but
range(SFs/SFs_zerosCount)
SFs/SFs_zerosCount
GM_referenceSample/GM_referenceSample_zerosCount
ps2
ps
length(GM_referenceSample))
length(GM_referenceSample)
# let's calculate ourselfs for samples 1 and 2
OUTT <- as(otu_table(ps2), "matrix")
# let's calculate ourselfs for samples 1 and 2
OTUT <- as(otu_table(ps2), "matrix")
dim(OTUT)
# let's calculate ourselfs for samples 1 and 2
OTUT <- t(as(otu_table(ps2), "matrix"))
dim(OTUT)
colnames(OTUT)[1:2]
OTUT <- OTUT[,1:2]
dim(OTUT)
OTUT_Ratios <- OTUT/GM_referenceSample
View(OTUT)
View(OTUT_Ratios)
View(OTUT)
OTUT_Ratios_zerosCount <- OTUT/GM_referenceSample_zerosCount
View(OTUT_Ratios_zerosCount)
View(OTUT_Ratios)
Diff <- OTUT_Ratios/OTUT_Ratios_zerosCount
View(Diff)
range(Diff)
range(Diff, na.rm = TRUE)
apply(OTUT_Ratios, 2, median)
apply(OTUT_Ratios[OTUT_Ratios > 0], 2, median) # would result in 0,
OTUT_Ratios[OTUT_Ratios > 0]
lapply(OTUT_Ratios, function(ratios){median(counts[counts>0])})
lapply(OTUT_Ratios, function(ratios){median(ratios[ratios>0])})
View(OTUT_Ratios)
lapply(as.data.frame(OTUT_Ratios), function(ratios){median(ratios[ratios>0])})
SFs[1:2]
?rpois
total <- 50/773
toral
50/773
lambda <- 50/773
rpois(7000, lambda = lambda)
sum(rpois(7000, lambda = lambda))
# - install packages -
# NB: all packages have to be installed, usually via install.packages()
# some packages you need to install via bioconductor, e.g.:
# source("https://bioconductor.org/biocLite.R")
# biocLite("phyloseq")
# --
# - load packages -
library(phyloseq); # packageVersion("phyloseq")
library(dada2); # packageVersion("dada2")
library(vegan); # packageVersion("vegan")
library(ggplot2); # packageVersion("ggplot2")
library(dplyr); # packageVersion("dplyr")
library(tidyr); # packageVersion("tidyr")
library(gridExtra); # packageVersion("gridExtra")
library(xtable); # packageVersion("xtable")
library(RVAideMemoire); #packageVersion("RVAideMemoire")
library(viridis); # packageVersion("viridis")
library(scales); # packageVersion("scales") # for the oob = squish option in gradient plots
library(ggthemes); # packageVersion("ggthemes")
library(DESeq2); # packageVersion("DESeq2")
library(ggpubr); # packageVersion("ggpubr")
library(RColorBrewer)
library(pheatmap)
library(grid)
library(breakaway)
library(bookdown)
# library(coin) # only needed if using test_differential_abundance_WilcoxonsingleManiCoin
# - packaged from Mani's analysis that I could add if needed-
# library(cowplot)
# library(ade4)
# library(ggrepel)
# library(ggforce)
# library(kableExtra)
# library(bindrcpp)
# library(stringr)
# library(BiocParallel)
# library(microbiomeX)
# --
